#+TITLE: 05 - Spheres
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Rays

  Rays have a point as origin and a vector as direction.

  #+NAME: rays_create_test
  #+BEGIN_SRC clojure
  (testing "Creating and querying a ray"
    (let [o (t/point 1. 2. 3.)
          d (t/vector 4. 5. 6.)
          r (ray o d)]
      (is (= o
             (:origin r)))
      (is (= d
             (:direction r)))))
  #+END_SRC

  #+NAME: rays_create
  #+BEGIN_SRC clojure
  (defn ray [origin direction]
    {:origin origin
     :direction direction})
  #+END_SRC

  We can get the point at any distance from a ray's origin.

  #+NAME: rays_pos_test
  #+BEGIN_SRC clojure
  (testing "Computing a point from a distance"
    (let [r (ray (t/point 2. 3. 4.) (t/vector 1. 0. 0.))]
      (is (= (t/point 2. 3. 4.)
             (pos r 0)))
      (is (= (t/point 3. 3. 4.)
             (pos r 1)))
      (is (= (t/point 1. 3. 4.)
             (pos r -1)))
      (is (= (t/point 4.5 3. 4.)
             (pos r 2.5)))))
  #+END_SRC

  #+NAME: rays_pos
  #+BEGIN_SRC clojure
  (defn pos [r t]
    (t/add (:origin r) (t/mul (:direction r) t)))
  #+END_SRC

** Transformations

   Translating a ray only translates the origin and doesn't change the direction.

   Scaling a ray scales both the origin and direction.

   #+NAME: rays_trans_test
   #+BEGIN_SRC clojure
   (testing "Translating a ray"
     (let [r (ray (t/point 1. 2. 3.) (t/vector 0. 1. 0.))
           mt (tr/translation 3. 4. 5.)
           r2 (transform r mt)]
       (is (= (t/point 4. 6. 8.)
              (:origin r2)))
       (is (= (t/vector 0. 1. 0.)
              (:direction r2)))))

   (testing "Scaling a ray"
     (let [r (ray (t/point 1. 2. 3.) (t/vector 0. 1. 0.))
           mt (tr/scaling 2. 3. 4.)
           r2 (transform r mt)]
       (is (= (t/point 2. 6. 12.)
              (:origin r2)))
       (is (= (t/vector 0. 3. 0.)
              (:direction r2)))))
   #+END_SRC

   #+NAME: rays_trans
   #+BEGIN_SRC clojure
   (defn transform [{:keys [origin direction]} t]
     {:origin (m/mul t origin)
      :direction (m/mul t direction)})
   #+END_SRC

* Spheres

  For now Speres are simple maps.

  #+NAME: spheres_create
  #+BEGIN_SRC clojure
  (defn sphere
    ([t]
     {:transform t
      :inverse-t (m/inverse t)})
    ([]
     (sphere (m/id 4))))
  #+END_SRC

  A ray aways interesects a sphere at 2 points, even when tangent, or it totally misses the sphere.
  - when a ray is tangent to a sphere, both distances are equals.
  - when the ray originates inside a sphere, one of the distance is negative.
  - when the sphere is behing the ray's origin, both distances are negatives.
  The first intersection distance is always the smallest.

  #+NAME: spheres_ray_int_test
  #+BEGIN_SRC clojure
  (testing "A ray intersects a sphere at two points"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= 4.
             (:t (first xs))))
      (is (= 6.
             (:t (second xs))))))

  (testing "A ray intersects a sphere at a tangent"
    (let [ra (r/ray (t/point 0. 1. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= 5.
             (:t (first xs))))
      (is (= 5.
             (:t (second xs))))))

  (testing "A ray misses a sphere"
    (let [ra (r/ray (t/point 0. 2. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 0
             (count xs)))))

  (testing "A ray originates inside a sphere"
    (let [ra (r/ray (t/point 0. 0. 0.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= -1.
             (:t (first xs))))
      (is (= 1.
             (:t (second xs))))))

  (testing "A sphere is behind a ray"
    (let [ra (r/ray (t/point 0. 0. 5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= -6.
             (:t (first xs))))
      (is (= -4.
             (:t (second xs))))))

  (testing "Intersect sets the object on the intersection"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= s
             (:object (first xs))))
      (is (= s
             (:object (second xs))))))
  #+END_SRC

  #+NAME: spheres_ray_int
  #+BEGIN_SRC clojure
  (defn intersect [{:keys [inverse-t] :as s} ra]
    (let [{:keys [origin direction]} (r/transform ra inverse-t)
          s->ra (t/sub origin (t/point 0. 0. 0.))
          two-a (* (t/dot direction direction) 2)
          b (* 2 (t/dot direction s->ra))
          c (- (t/dot s->ra s->ra) 1)
          discriminant (- (* b b) (* 2 two-a c))]
      (if (< discriminant 0)
        []
        (let [s-d (Math/sqrt discriminant)
              t1 (/ (- 0 s-d b) two-a)
              t2 (/ (- s-d b) two-a)
              i1 (i/intersection t1 s)
              i2 (i/intersection t2 s)]
          (if (< t1 t2)
            (i/intersections i1 i2)
            (i/intersections i2 i1))))))
  #+END_SRC

** Transformations

   Spheres has a transform property.

   #+NAME: spheres_trans_test
   #+BEGIN_SRC clojure
   (testing "A sphere's default transformation"
     (is (= (m/id 4)
            (:transform (sphere)))))

   (testing "Changing a sphere's transformation"
     (let [t (tr/translation 2. 3. 4.)
           s (sphere t)]
       (:transform s)))
   #+END_SRC

   Transformations of the spheres are applied to the ray when calculating the intersections.

   #+NAME: spheres_int_trans_test
   #+BEGIN_SRC clojure
   (testing "Intersecting a scaled sphere with a ray"
     (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
           s (sphere (tr/scaling 2. 2. 2.))
           xs (intersect s ra)]
       (is (= 2
              (count xs)))
       (is (= 3.
              (:t (first xs))))
       (is (= 7.
              (:t (second xs))))))

   (testing "Intersecting a translated sphere with a ray"
     (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
           s (sphere (tr/translation 5. 0. 0.))
           xs (intersect s ra)]
       (is (= 0
              (count xs)))))
   #+END_SRC

* Intersections

  Intersections store the object hit and the distance from origin on the ray.

  #+NAME: ints_create_test
  #+BEGIN_SRC clojure
  (testing "An intersection encapsulates 't' and 'object'"
    (let [s {:object :test}
          i (intersection 3.5 s)]
      (is (= 3.5
             (:t i)))
      (is (= s
             (:object i)))))

  (testing "Aggregating intersections"
    (let [s {:object :test}
          i1 (intersection 1. s)
          i2 (intersection 2. s)
          xs (intersections i1 i2)]
      (is (= 2
             (count xs)))
      (is (= 1.
             (:t (first xs))))
      (is (= 2.
             (:t (second xs))))))
  #+END_SRC

  #+NAME: ints_create
  #+BEGIN_SRC clojure
  (defn intersection [t object]
    {:t t
     :object object})

  (def intersections vector)
  #+END_SRC

  We can find a hit in a list of intersections. It's always the lowest non-negative intersection.

  #+NAME: ints_hit_test
  #+BEGIN_SRC clojure
  (testing "The hit, when all intersections have positive t"
    (let [s {:object :test}
          i1 (intersection 1. s)
          i2 (intersection 2. s)
          xs (intersections i2 i1)]
      (is (= i1
             (hit xs)))))

  (testing "The hit, when some intersections have negative t"
    (let [s {:object :test}
          i1 (intersection -1. s)
          i2 (intersection 2. s)
          xs (intersections i2 i1)]
      (is (= i2
             (hit xs)))))

  (testing "The hit, when all intersections have negative t"
    (let [s {:object :test}
          i1 (intersection -1. s)
          i2 (intersection -2. s)
          xs (intersections i2 i1)]
      (is (= nil
             (hit xs)))))

  (testing "The hit is always the lowest non-negative intersection"
    (let [s {:object :test}
          i1 (intersection 5. s)
          i2 (intersection 7. s)
          i3 (intersection -3. s)
          i4 (intersection 2. s)
          xs (intersections i2 i1 i3 i4)]
      (is (= i4
             (hit xs)))))
  #+END_SRC

  #+NAME: ints_hit
  #+BEGIN_SRC clojure
  (defn hit [is]
    (first (sort-by :t (filter #(< 0 (:t %)) is))))
  #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/rays.clj
  (ns rt-clj.rays
    (:require [rt-clj.matrices :as m]
              [rt-clj.tuples :as t]))


  <<rays_create>>


  <<rays_pos>>


  <<rays_trans>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/rays_test.clj
  (ns rt-clj.rays-test
    (:require [clojure.test :refer :all]
              [rt-clj.rays :refer :all]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]))

  (deftest rays-test
    <<rays_create_test>>

    <<rays_pos_test>>

    <<rays_trans_test>>)
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/intersections.clj
  (ns rt-clj.intersections)


  <<ints_create>>


  <<ints_hit>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/intersections_test.clj
  (ns rt-clj.intersections-test
    (:require [clojure.test :refer :all]
              [rt-clj.intersections :refer :all]))

  (deftest intersections-test
    <<ints_create_test>>

    <<ints_hit_test>>)
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/spheres.clj
  (ns rt-clj.spheres
    (:require [rt-clj.intersections :as i]
              [rt-clj.matrices :as m]
              [rt-clj.rays :as r]
              [rt-clj.tuples :as t]))


  <<spheres_create>>

  <<spheres_ray_int>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/spheres_test.clj
  (ns rt-clj.spheres-test
    (:require [clojure.test :refer :all]
              [rt-clj.spheres :refer :all]
              [rt-clj.matrices :as m]
              [rt-clj.rays :as r]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]))

  (deftest spheres-test
    <<spheres_ray_int_test>>

    <<spheres_trans_test>>

    <<spheres_int_trans_test>>)
  #+END_SRC
* Example

  Let's draw a sphere, in =[0. 0. 0.]=, scaled by a factor =0.5= in the =y= direction.

  The rays origin is in =[3. 0. 0.]= and the projection screen is the plane =[-3. y z]=.

  Pixels will be black if the ray misses, red if the ray hits the sphere.

  #+BEGIN_SRC clojure :exports code :results output :file ../samples/sphere_ray_example.ppm
  (require '[rt-clj.canvas :as ca])
  (require '[rt-clj.colors :as co])
  (require '[rt-clj.intersections :as in])
  (require '[rt-clj.rays :as ra])
  (require '[rt-clj.spheres :as sp])
  (require '[rt-clj.transformations :as tr])
  (require '[rt-clj.tuples :as tu])

  (let [miss-col (co/color 0. 0. 0.)
        hit-col (co/color 1. 0. 0.)
        s (sp/sphere (tr/scaling 1. 0.5 1.))
        o (tu/point 3. 0. 0.)
        h 256
        w 256
        sc-min -3.
        sc-max 3.
        sc-width (- sc-max sc-min)
        pixel-step-w (/ sc-width w)
        pixel-step-h (/ sc-width h)
        hits (mapv (fn[i]
                     (mapv (fn [j]
                             (let [screen-p (tu/point -3.
                                                      (+ -3. (* i pixel-step-w))
                                                      (+ -3. (* j pixel-step-h)))
                                   ray-d (tu/sub screen-p o)
                                   ray (ra/ray o ray-d)]
                               (in/hit (sp/intersect s ray)))) (range w))) (range h))
        cv (reduce (fn [c i]
                     (reduce (fn [c j]
                               (ca/assoc-at c i j (if (get-in hits [i j])
                                                    hit-col
                                                    miss-col)))
                             c (range w)))
                   (ca/canvas w h) (range h))]
    ;; print the PPM file
    (println
      (clojure.string/join "\n" (ca/ppm-rows cv))))
  #+END_SRC

  [[file:../samples/sphere_ray_example.png]]
