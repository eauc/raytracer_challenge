#+TITLE: 03 - Matrices
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Creation

  Matrices are stored as simple vectors of rows.

  We can inspect any element.

  #+NAME: matrices_create_test
  #+BEGIN_SRC clojure
  (testing "Constructing and inspecting a 4x4 matrix"
    (let [m (matrix [[1. 2. 3. 4.]
                     [5.5 6.5 7.5 8.5]
                     [9 10 11 12]
                     [13.5 14.5 15.5 16.5]])]
      (is (= 4
             (height m)))
      (is (= 4
             (width m)))
      (is (= 1.
             (get-at m 0 0)))
      (is (= 4.
             (get-at m 0 3)))
      (is (= 5.5
             (get-at m 1 0)))
      (is (= 7.5
             (get-at m 1 2)))
      (is (= 11
             (get-at m 2 2)))
      (is (= 13.5
             (get-at m 3 0)))
      (is (= 15.5
             (get-at m 3 2)))))

  (testing "A 2x2 matrix ought to be representable"
    (let [m (matrix [[-3 5 ]
                     [1 -2]])]
      (is (= 2
             (height m)))
      (is (= 2
             (width m)))
      (is (= -3
             (get-at m 0 0)))
      (is (= 5
             (get-at m 0 1)))
      (is (= 1
             (get-at m 1 0)))
      (is (= -2
             (get-at m 1 1)))))

  (testing "A 3x3 matrix ought to be representable"
    (let [m (matrix [[-3 5 0]
                     [1 -2 -7]
                     [0 1 1]])]
      (is (= 3
             (height m)))
      (is (= 3
             (width m)))
      (is (= -3
             (get-at m 0 0)))
      (is (= -2
             (get-at m 1 1)))
      (is (= 1
             (get-at m 2 2)))))
  #+END_SRC

  #+NAME: matrices_create
  #+BEGIN_SRC clojure
  (def matrix identity)

  (def height count)

  (def width (comp count first))

  (defn get-at [m i j]
    (get-in m [i j]))
  #+END_SRC

* Equality

  Matrix with very similar members are equals.

  #+NAME: matrices_eq_test
  #+BEGIN_SRC clojure
  (testing "Matrix equality with identical matrices"
    (is (eq? (matrix [[1 2 3 4]
                      [2 3 4 5]
                      [3 4 5 6]
                      [4 5 6 7]])
             (matrix [[1 2 3 4]
                      [2 3 4 5]
                      [3 4 5 6]
                      [4 5 6 7]]))))

  (testing "Matrix equality with different matrices"
    (is (not (eq? (matrix [[1 2 3 4]
                           [2 3 4 5]
                           [3 4 5 6]
                           [4 5 6 7]])
                  (matrix [[0 2 3 4]
                           [2 3 4 5]
                           [3 4 5 6]
                           [4 5 6 7]])))))
  #+END_SRC

  #+NAME: matrices_eq
  #+BEGIN_SRC clojure
  (defn eq? [a b]
    (every? true? (map t/eq? a b)))
  #+END_SRC

* Transposition

  Invert the rows & cols of a matrix.

  #+NAME: matrices_transpose_test
  #+BEGIN_SRC clojure
  (testing "Transposing a matrix"
    (is (= (matrix [[0 9 3 0]
                    [9 8 0 8]
                    [1 8 5 3]
                    [0 0 5 8]])
           (transpose (matrix [[0 9 1 0]
                               [9 8 8 0]
                               [3 0 5 5]
                               [0 8 3 8]])))))
  #+END_SRC

  #+NAME: matrices_transpose
  #+BEGIN_SRC clojure
  (defn transpose [m]
    (let [w (width m)]
      (mapv (fn [col]
              (mapv #(get % col) m)) (range w))))
  #+END_SRC

* Multiplication

  We can multiply matrices.

  Element =[i,j]= is the dot product of A's row =[i]= & B's col =[j]=.

  #+NAME: matrices_mul_test
  #+BEGIN_SRC clojure
  (testing "Multiplying two matrices"
    (is (= (matrix [[24 49 98 196]
                    [31 64 128 256]
                    [38 79 158 316]
                    [45 94 188 376]])
           (mul (matrix [[1 2 3 4]
                         [2 3 4 5]
                         [3 4 5 6]
                         [4 5 6 7]])
                (matrix [[0 1 2 4]
                         [1 2 4 8]
                         [2 4 8 16]
                         [4 8 16 32]])))))

  (testing "A matrix multiplied by a tuple"
    (is (= (t/tuple 18 24 33 1)
           (mul (matrix [[1 2 3 4]
                         [2 4 4 2]
                         [8 6 4 1]
                         [0 0 0 1]])
                (t/tuple 1 2 3 1)))))
  #+END_SRC

  #+NAME: matrices_mul
  #+BEGIN_SRC clojure
  (defn mul-tuple [m t]
    (mapv #(t/dot % t) m))

  (defn mul [a b]
    (if (not (vector? (first b)))
      (mul-tuple a b)
      (mapv #(mul-tuple (transpose b) %) a)))
  #+END_SRC

** Indentity matrix

   Multiplying any matrix or tuple by the identity leaves them unchanged.

   #+NAME: matrices_id_test
   #+BEGIN_SRC clojure
   (testing "Multiplying a matrix by the identity"
     (let [m (matrix [[0. 1. 2. 4.]
                      [1. 2. 4. 8.]
                      [2. 4. 8. 16.]
                      [4. 8. 16. 32.]])]
       (is (= m
              (mul m (id 4))))))

   (testing "Multiplying identity by a tuple"
     (let [a (t/tuple 1. 2. 3. 4.)]
       (is (= a
              (mul (id 4) a)))))
   #+END_SRC

   #+NAME: matrices_id
   #+BEGIN_SRC clojure
   (defn id [n]
     (mapv #(vec (concat (repeat % 0.) [1.] (repeat (dec (- n %)) 0.))) (range n)))
   #+END_SRC

* Inversion


  A matrix is invertible if the determinant is not 0.

  #+NAME: matrices_invertible_test
  #+BEGIN_SRC clojure
  (testing "Testing an invertible matrix for invertibility"
    (let [m (matrix [[6 4 4 4]
                     [5 5 7 6]
                     [4 -9 3 -7]
                     [9 1 7 -6]])]
      (is (= -2120
             (det m)))
      (is (invertible? m))))

  (testing "Testing an non-invertible matrix for invertibility"
    (let [m (matrix [[-4 2 -2 -3]
                     [9 6 2 6]
                     [0 -5 1 -5]
                     [0 0 0 0]])]
      (is (= 0
             (det m)))
      (is (not (invertible? m)))))
  #+END_SRC

  #+NAME: matrices_invertible
  #+BEGIN_SRC clojure
  (defn invertible? [m]
    (not (t/close? 0 (det m))))
  #+END_SRC

  To calculate the inverse of a matrix:
  - we calculate the matrix of the cofactors.
  - we transpose those cofactors.
  - we divide each element by the determinant.

  #+NAME: matrices_inverse_test
  #+BEGIN_SRC clojure
  (testing "Calculating the inverse of a"
    (let [m (matrix [[-5. 2. 6. -8.]
                     [1. -5. 1. 8.]
                     [7. 7. -6. -7.]
                     [1. -3. 7. 4.]])]
      (is (= 532.
             (det m)))
      (is (= -160.
             (cofactor m 2 3)))
      (is (eq? (matrix [[0.21805 0.45113 0.24060 -0.04511]
                        [-0.80827 -1.45677 -0.44361 0.52068]
                        [-0.07895 -0.22368 -0.05263 0.19737]
                        [-0.52256 -0.81391 -0.30075 0.30639]])
               (inverse m)))))

  (testing "The inverse of a non-invertible matrix is nil"
    (is (= nil
           (inverse (matrix [[-4 2 -2 -3]
                             [9 6 2 6]
                             [0 -5 1 -5]
                             [0 0 0 0]])))))

  (testing "Multiplying a product by its inverse"
    (let [a (matrix [[3. -9. 7. 3.]
                     [3. -8. 2. -9.]
                     [-4. 4. 4. 1.]
                     [-6. 5. -1. 1.]])
          b (matrix [[8. 2. 2. 2.]
                     [3. -1. 7. 0.]
                     [7. 0. 5. 4.]
                     [6. -2. 0. 5.]])]
      (is (eq? a
               (mul (mul a b) (inverse b))))))

  (testing "Multiplying a matrix by its gives the identity"
    (let [a (matrix [[3. -9. 7. 3.]
                     [3. -8. 2. -9.]
                     [-4. 4. 4. 1.]
                     [-6. 5. -1. 1.]])]
      (is (eq? (id 4)
               (mul a (inverse a))))))

  (testing "The inverse of identity is identity"
    (is (= (id 4)
           (inverse (id 4)))))
  #+END_SRC

  #+NAME: matrices_inverse
  #+BEGIN_SRC clojure
  (defn cofactors [m]
    (let [h (height m)
          w (width m)
          rw (range w)]
      (mapv (fn [i]
              (mapv #(cofactor m i %) rw)) (range h))))

  (defn inverse [m]
    (let [cfs (cofactors m)
          t-cfs (transpose cfs)
          d (t/dot (first m) (first cfs))]
      (if (t/close? 0 d)
        nil
        (mapv #(t/div % d) t-cfs))))
  #+END_SRC

** Determinant

   Inverting matrices starts with finding the determinant.

   For 2x2 matrices, the determinant is =a.d - b.c=
   #+attr_latex: :mode math :environment matrix
   | a | b |
   | c | d |

   #+NAME: matrices_det2_test
   #+BEGIN_SRC clojure
   (testing "Calculating the determinant of a 2x2 matrix"
     (is (= 17
            (det (matrix [[1 5]
                          [-3 2]])))))
   #+END_SRC

   For larger matrices:
   - we extract the first row.
   - we calculate the vector of the cofactors for each element of the first row.
   - the determinant is the dot product of the first row with the cofactors vector.

   #+NAME: matrices_det_test
   #+BEGIN_SRC clojure
   (testing "Calculating the determinant of a 3x3 matrix"
     (let [m (matrix [[1 2 6]
                      [-5 8 -4]
                      [2 6 4]])]
       (is (= 56
              (cofactor m 0 0)))
       (is (= 12
              (cofactor m 0 1)))
       (is (= -46
              (cofactor m 0 2)))
       (is (= -196
              (det m)))))

   (testing "Calculating the determinant of a 4x4 matrix"
     (let [m (matrix [[-2 -8 3 5]
                      [-3 1 7 3]
                      [1 2 -9 6]
                      [-6 7 7 -9]])]
       (is (= 690
              (cofactor m 0 0)))
       (is (= 447
              (cofactor m 0 1)))
       (is (= 210
              (cofactor m 0 2)))
       (is (= 51
              (cofactor m 0 3)))
       (is (= -4071
              (det m)))))
   #+END_SRC

   #+NAME: matrices_det
   #+BEGIN_SRC clojure
   (defn det [m]
     (let [w (width m)]
       (if (and (= 2 (height m))
                (= 2 w))
         (let [[[a b][c d]] m]
           (- (* a d) (* b c)))
         (let [cofs (mapv #(cofactor m 0 %) (range w))]
           (t/dot (first m) cofs)))))
   #+END_SRC

** Submatrices

   Finding the determinant of matrices larger than 2x2, involves finding the submatrices.

   A submatrice of A for element [i,j] is the matrix obtained by removing row i and col j of A.

   #+NAME: matrices_subm_test
   #+BEGIN_SRC clojure
   (testing "A submatrix of a 3x3 matrix is a 2x2 matrix"
     (is (= (matrix [[-3 2]
                     [0 6]])
            (subm (matrix [[1 5 0]
                           [-3 2 7]
                           [0 6 -3]]) 0 2))))

   (testing "A submatrix of a 4x4 matrix is a 3x3 matrix"
     (is (= (matrix [[-6 1 6]
                     [-8 8 6]
                     [-7 -1 1]])
            (subm (matrix [[-6 1 1 6]
                           [-8 5 8 6]
                           [-1 0 8 2]
                           [-7 1 -1 1]]) 2 1))))
   #+END_SRC

   #+NAME: matrices_subm
   #+BEGIN_SRC clojure
   (defn- drop-nth [v n]
     (vec (concat (subvec v 0 n) (subvec v (inc n)))))

   (defn subm [m i j]
     (mapv #(drop-nth % j) (drop-nth m i)))
   #+END_SRC

** Minors & Cofactors

   The minor of an element at row i and column j is the determinant of the submatrix at [i,j].

   #+NAME: matrices_minor_test
   #+BEGIN_SRC clojure
   (testing "Calculating a minor of a 3x3 matrix"
     (let [m (matrix [[3 5 0]
                      [2 -1 -7]
                      [6 -1 5]])]
       (is (= 25
              (det (subm m 1 0))
              (minor m 1 0)))))
   #+END_SRC

   #+NAME: matrices_minor
   #+BEGIN_SRC clojure
   (declare det)

   (defn minor [m i j]
     (det (subm m i j)))
   #+END_SRC

   The cofactor of [i,j] is the minor of [i,j], negated if =i+j= is odd.

   #+NAME: matrices_cofactor_test
   #+BEGIN_SRC clojure
   (testing "Calculating a cofactor of a 3x3 matrix"
     (let [m (matrix [[3 5 0]
                      [2 -1 -7]
                      [6 -1 5]])]
       (is (= -12
              (cofactor m 0 0)))
       (is (= -25
              (cofactor m 1 0)))))
   #+END_SRC

   #+NAME: matrices_cofactor
   #+BEGIN_SRC clojure
   (defn cofactor [m i j]
     (let [mi (minor m i j)]
       (if (odd? (+ i j))
         (- 0 mi)
         mi)))
   #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

   #+BEGIN_SRC clojure :tangle ../src/rt_clj/matrices.clj
   (ns rt-clj.matrices
     (:require [rt-clj.tuples :as t]))


   <<matrices_create>>

   <<matrices_eq>>


   <<matrices_transpose>>

   <<matrices_mul>>

   <<matrices_id>>


   <<matrices_subm>>

   <<matrices_minor>>

   <<matrices_cofactor>>

   <<matrices_det>>

   <<matrices_invertible>>

   <<matrices_inverse>>
   #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/matrices_test.clj
  (ns rt-clj.matrices-test
    (:require [clojure.test :refer :all]
              [rt-clj.matrices :refer :all]
              [rt-clj.tuples :as t]))

  (deftest matrices-test
    <<matrices_create_test>>

    <<matrices_eq_test>>

    <<matrices_transpose_test>>

    <<matrices_mul_test>>

    <<matrices_id_test>>

    <<matrices_subm_test>>

    <<matrices_minor_test>>

    <<matrices_cofactor_test>>

    <<matrices_det2_test>>

    <<matrices_det_test>>

    <<matrices_invertible_test>>

    <<matrices_inverse_test>>)
  #+END_SRC
