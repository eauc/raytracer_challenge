#+TITLE: 16 - Cylinders
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

[[file:../samples/cylinders_example.png]]

* Creation

  #+NAME: cyls_create
  #+BEGIN_SRC clojure
  (defn cylinder
    ([transform material]
     (-> (sh/shape local-bounds local-intersect local-normal transform material)
         (assoc
           :closed? false
           :minimum (- t/infinity)
           :maximum t/infinity)))
    ([transform]
     (cylinder transform mr/default-material))
    ([]
     (cylinder (m/id 4) mr/default-material)))
  #+END_SRC

* Bounds

  #+NAME: cyls_bounds
  #+BEGIN_SRC clojure
  (defn local-bounds
    [{:keys [minimum maximum] :as cyl}]
    {:min (t/point -1. minimum -1.)
     :max (t/point 1. maximum 1.)})
  #+END_SRC

* Intersections

  #+NAME: cyls_ints_test
  #+BEGIN_SRC clojure
  (testing "A ray misses a cylinder"
    (are [origin direction]
        (= []
           (local-intersect (cylinder) (r/ray origin (t/norm direction))))
        (t/point 1. 0. 0.) (t/vector 0. 1. 0.)
        (t/point 0. 0. 0.) (t/vector 0. 1. 0.)
        (t/point 0. 0. -5.) (t/vector 1. 1. 1.)))

  (testing "A ray strikes a cylinder"
    (are [origin direction t]
        (t/eq? t
               (mapv :t (local-intersect (cylinder) (r/ray origin (t/norm direction)))))
        (t/point 1. 0. -5.) (t/vector 0. 0. 1.) [5. 5.]
        (t/point 0. 0. -5.) (t/vector 0. 0. 1.) [4. 6.]
        (t/point 0.5 0. -5.) (t/vector 0.1 1. 1.) [6.80798 7.08872]))
  #+END_SRC

  We first calculate a pseudo-discrimant, which is negative is the ray doesn't intersect the cylinder.

  Otherwise we use it to calculate roots and the intersections.

  We also need to calculate the =y= coordinate at each intersection and check it is between =minimum= and =maximum= properties for the cylinder. If not, the intersection is not valid.

  If the cylinder is closed, we need to calculate the intersections with the caps.

  #+NAME: cyls_ints
  #+BEGIN_SRC clojure
  (defn local-intersect
    [{:keys [minimum maximum] :as cyl}
     {:keys [direction origin] :as ray}]
    (intersect-caps
      cyl ray
      (let [a (* (+ (Math/pow (t/x direction) 2.)
                    (Math/pow (t/z direction) 2.))
                 2.)]
        (if (t/close? a 0.)
          []
          (let [b (+ (* 2 (t/x origin) (t/x direction))
                     (* 2 (t/z origin) (t/z direction)))
                c (+ (Math/pow (t/x origin) 2.)
                     (Math/pow (t/z origin) 2.)
                     -1.)
                disc (- (Math/pow b 2.) (* 2. a c))]
            (if (< disc 0.)
              []
              (let [disc-sqrt (Math/sqrt disc)
                    t0 (/ (- 0. b disc-sqrt) a)
                    t1 (/ (+ (- 0. b) disc-sqrt) a)
                    y0 (+ (t/y origin) (* t0 (t/y direction)))
                    y1 (+ (t/y origin) (* t1 (t/y direction)))]
                (filterv
                  identity
                  [(if (< minimum y0 maximum) (i/intersection t0 cyl))
                   (if (< minimum y1 maximum) (i/intersection t1 cyl))]))))))))
  #+END_SRC

* Normal

  #+NAME: cyls_normal_test
  #+BEGIN_SRC clojure
  (testing "Normal vector on a cylinder"
    (are [point normal]
        (= normal
           (local-normal (cylinder) point {}))
        (t/point 1. 0. 0.) (t/vector 1. 0. 0.)
        (t/point 0. 5. -1.) (t/vector 0. 0. -1.)
        (t/point 0. -2. 1.) (t/vector 0. 0. 1.)
        (t/point -1. 1. 0.) (t/vector -1. 0. 0.)))
  #+END_SRC

  Finding the normal of a cylinder is quite easy, you just need to remove the =y= coordinate of the point on the surface.

  When the point is on one of the cylinder's cap, just return =+/-u[y]=.

  #+NAME: cyls_normal
  #+BEGIN_SRC clojure
  (defn local-normal
    [{:keys [minimum maximum] :as cyl} point _]
    (let [d (+ (Math/pow (t/x point) 2.)
               (Math/pow (t/z point) 2.))]
      (cond
        (and (< d 1) (>= (t/y point) (- maximum t/epsilon))) (t/vector 0. 1. 0.)
        (and (< d 1) (<= (t/y point) (+ minimum t/epsilon))) (t/vector 0. -1. 0.)
        :else (t/vector (t/x point) 0. (t/z point)))))
  #+END_SRC

* Truncated cylinders

  #+NAME: cyls_trunc_test
  #+BEGIN_SRC clojure
  (testing "Intersecting a constrained cylinder"
    (let [cyl (assoc (cylinder)
                     :minimum 1
                     :maximum 2)]
      (are [origin direction cnt]
          (= cnt
             (count (local-intersect cyl (r/ray origin (t/norm direction)))))
          (t/point 0. 1.5 0.) (t/vector 0.1 1. 0.) 0
          (t/point 0. 3. -5.) (t/vector 0. 0. 1.) 0
          (t/point 0. 0. -5.) (t/vector 0. 0. 1.) 0
          (t/point 0. 2. -5.) (t/vector 0. 0. 1.) 0
          (t/point 0. 1. -5.) (t/vector 0. 0. 1.) 0
          (t/point 0. 1.5 -2.) (t/vector 0. 0. 1.) 2)))
  #+END_SRC

* Closed cylinders

  #+NAME: cyls_closed_test
  #+BEGIN_SRC clojure
  (testing "Intersecting the caps of a closed cylinder"
    (let [cyl (assoc (cylinder)
                     :minimum 1
                     :maximum 2
                     :closed? true)]
      (are [origin direction cnt]
          (= cnt
             (count (local-intersect cyl (r/ray origin (t/norm direction)))))
          (t/point 0. 3. 0.) (t/vector 0. -1. 0.) 2
          (t/point 0. 3. -2.) (t/vector 0. -1. 2.) 2
          (t/point 0. 4. -2.) (t/vector 0. -1. 1.) 2
          (t/point 0. 0. -2.) (t/vector 0. 1. 2.) 2
          (t/point 0. -1. -2.) (t/vector 0. 1. 1.) 2)))

  (testing "The normal vector on a cylinder's end caps"
    (let [cyl (assoc (cylinder)
                     :minimum 1
                     :maximum 2
                     :closed? true)]
      (are [point normal]
          (= normal
             (local-normal cyl point {}))
          (t/point 0. 1. 0.) (t/vector 0. -1. 0.)
          (t/point 0.5 1. 0.) (t/vector 0. -1. 0.)
          (t/point 0. 1. 0.5) (t/vector 0. -1. 0.)
          (t/point 0. 2. 0.) (t/vector 0. 1. 0.)
          (t/point 0.5 2. 0.) (t/vector 0. 1. 0.)
          (t/point 0. 2. 0.5) (t/vector 0. 1. 0.))))
  #+END_SRC

  =intersect-caps= checks to see if the given ray intersects the end caps of the given cylinder, and adds the points of intersection (if any) to the hits collection.

  #+NAME: cyls_closed
  #+BEGIN_SRC clojure
  (defn check-cap
    [{:keys [origin direction] :as ray} t]
    (let [x (+ (t/x origin) (* t (t/x direction)))
          z (+ (t/z origin) (* t (t/z direction)))]
      (>= 1. (+ (Math/pow x 2.)
                (Math/pow z 2.)))))


  (defn intersect-caps
    [{:keys [closed? minimum maximum] :as cyl}
     {:keys [origin direction] :as ray}
     ints]
    (if (or (not closed?)
            (t/close? 0. (t/y direction)))
      ints
      (let [t-min (/ (- minimum (t/y origin)) (t/y direction))
            t-max (/ (- maximum (t/y origin)) (t/y direction))
            cap-min? (check-cap ray t-min)
            cap-max? (check-cap ray t-max)]
        (into
          []
          (concat
            ints
            (filter identity [(if cap-min? (i/intersection t-min cyl))
                              (if cap-max? (i/intersection t-max cyl))]))))))
  #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/cylinders.clj
  (ns rt-clj.cylinders
    (:import java.lang.Math)
    (:require [rt-clj.intersections :as i]
              [rt-clj.matrices :as m]
              [rt-clj.materials :as mr]
              [rt-clj.shapes :as sh]
              [rt-clj.tuples :as t]))


  <<cyls_bounds>>


  <<cyls_closed>>


  <<cyls_ints>>


  <<cyls_normal>>


  <<cyls_create>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/cylinders_test.clj
  (ns rt-clj.cylinders-test
    (:require [clojure.test :refer :all]
              [rt-clj.cylinders :refer :all]
              [rt-clj.rays :as r]
              [rt-clj.tuples :as t]))

  (deftest cylinders-test

    <<cyls_ints_test>>

    <<cyls_normal_test>>

    <<cyls_trunc_test>>

    <<cyls_closed_test>>)
  #+END_SRC
