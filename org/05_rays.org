#+TITLE: 05 - Rays
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Creation

  Rays have a point as origin and a vector as direction.

  #+NAME: rays_create_test
  #+BEGIN_SRC clojure
  (testing "Creating and querying a ray"
    (let [o (t/point 1. 2. 3.)
          d (t/vector 4. 5. 6.)
          r (ray o d)]
      (is (= o
             (:origin r)))
      (is (= d
             (:direction r)))))
  #+END_SRC

  #+NAME: rays_create
  #+BEGIN_SRC clojure
  (defn ray [origin direction]
    {:origin origin
     :direction direction})
  #+END_SRC

  We can get the point at any distance from a ray's origin.

  #+NAME: rays_pos_test
  #+BEGIN_SRC clojure
  (testing "Computing a point from a distance"
    (let [r (ray (t/point 2. 3. 4.) (t/vector 1. 0. 0.))]
      (is (= (t/point 2. 3. 4.)
             (pos r 0)))
      (is (= (t/point 3. 3. 4.)
             (pos r 1)))
      (is (= (t/point 1. 3. 4.)
             (pos r -1)))
      (is (= (t/point 4.5 3. 4.)
             (pos r 2.5)))))
  #+END_SRC

  #+NAME: rays_pos
  #+BEGIN_SRC clojure
  (defn pos [r t]
    (t/add (:origin r) (t/mul (:direction r) t)))
  #+END_SRC

* Transformations

  Translating a ray only translates the origin and doesn't change the direction.

  Scaling a ray scales both the origin and direction.

  #+NAME: rays_trans_test
  #+BEGIN_SRC clojure
  (testing "Translating a ray"
    (let [r (ray (t/point 1. 2. 3.) (t/vector 0. 1. 0.))
          mt (tr/translation 3. 4. 5.)
          r2 (transform r mt)]
      (is (= (t/point 4. 6. 8.)
             (:origin r2)))
      (is (= (t/vector 0. 1. 0.)
             (:direction r2)))))

  (testing "Scaling a ray"
    (let [r (ray (t/point 1. 2. 3.) (t/vector 0. 1. 0.))
          mt (tr/scaling 2. 3. 4.)
          r2 (transform r mt)]
      (is (= (t/point 2. 6. 12.)
             (:origin r2)))
      (is (= (t/vector 0. 3. 0.)
             (:direction r2)))))
  #+END_SRC

  #+NAME: rays_trans
  #+BEGIN_SRC clojure
  (defn transform [{:keys [origin direction]} t]
    {:origin (m/mul t origin)
     :direction (m/mul t direction)})
  #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/rays.clj
  (ns rt-clj.rays
    (:require [rt-clj.matrices :as m]
              [rt-clj.tuples :as t]))


  <<rays_create>>


  <<rays_pos>>


  <<rays_trans>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/rays_test.clj
  (ns rt-clj.rays-test
    (:require [clojure.test :refer :all]
              [rt-clj.rays :refer :all]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]))

  (deftest rays-test
    <<rays_create_test>>

    <<rays_pos_test>>

    <<rays_trans_test>>)
  #+END_SRC
