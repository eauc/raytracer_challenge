#+TITLE: 07 - Spheres
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Creation

  For now Speres are simple maps.

  #+NAME: spheres_create
  #+BEGIN_SRC clojure
  (defn sphere
    ([t]
     {:transform t
      :inverse-t (m/inverse t)})
    ([]
     (sphere (m/id 4))))
  #+END_SRC

* Intersections

  A ray aways interesects a sphere at 2 points, even when tangent, or it totally misses the sphere.
  - when a ray is tangent to a sphere, both distances are equals.
  - when the ray originates inside a sphere, one of the distance is negative.
  - when the sphere is behing the ray's origin, both distances are negatives.
  The first intersection distance is always the smallest.

  #+NAME: spheres_ray_int_test
  #+BEGIN_SRC clojure
  (testing "A ray intersects a sphere at two points"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= 4.
             (:t (first xs))))
      (is (= 6.
             (:t (second xs))))))

  (testing "A ray intersects a sphere at a tangent"
    (let [ra (r/ray (t/point 0. 1. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= 5.
             (:t (first xs))))
      (is (= 5.
             (:t (second xs))))))

  (testing "A ray misses a sphere"
    (let [ra (r/ray (t/point 0. 2. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 0
             (count xs)))))

  (testing "A ray originates inside a sphere"
    (let [ra (r/ray (t/point 0. 0. 0.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= -1.
             (:t (first xs))))
      (is (= 1.
             (:t (second xs))))))

  (testing "A sphere is behind a ray"
    (let [ra (r/ray (t/point 0. 0. 5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= -6.
             (:t (first xs))))
      (is (= -4.
             (:t (second xs))))))

  (testing "Intersect sets the object on the intersection"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= s
             (:object (first xs))))
      (is (= s
             (:object (second xs))))))
  #+END_SRC

  #+NAME: spheres_ray_int
  #+BEGIN_SRC clojure
  (defn intersect [{:keys [inverse-t] :as s} ra]
    (let [{:keys [origin direction]} (r/transform ra inverse-t)
          s->ra (t/sub origin (t/point 0. 0. 0.))
          two-a (* (t/dot direction direction) 2)
          b (* 2 (t/dot direction s->ra))
          c (- (t/dot s->ra s->ra) 1)
          discriminant (- (* b b) (* 2 two-a c))]
      (if (< discriminant 0)
        []
        (let [s-d (Math/sqrt discriminant)
              t1 (/ (- 0 s-d b) two-a)
              t2 (/ (- s-d b) two-a)
              i1 (i/intersection t1 s)
              i2 (i/intersection t2 s)]
          (if (< t1 t2)
            (i/intersections i1 i2)
            (i/intersections i2 i1))))))
  #+END_SRC

* Transformations

  Spheres has a transform property.

  #+NAME: spheres_trans_test
  #+BEGIN_SRC clojure
  (testing "A sphere's default transformation"
    (is (= (m/id 4)
           (:transform (sphere)))))

  (testing "Changing a sphere's transformation"
    (let [t (tr/translation 2. 3. 4.)
          s (sphere t)]
      (:transform s)))
  #+END_SRC

  Transformations of the spheres are applied to the ray when calculating the intersections.

  #+NAME: spheres_int_trans_test
  #+BEGIN_SRC clojure
  (testing "Intersecting a scaled sphere with a ray"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere (tr/scaling 2. 2. 2.))
          xs (intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= 3.
             (:t (first xs))))
      (is (= 7.
             (:t (second xs))))))

  (testing "Intersecting a translated sphere with a ray"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere (tr/translation 5. 0. 0.))
          xs (intersect s ra)]
      (is (= 0
             (count xs)))))
  #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/spheres.clj
  (ns rt-clj.spheres
    (:require [rt-clj.intersections :as i]
              [rt-clj.matrices :as m]
              [rt-clj.rays :as r]
              [rt-clj.tuples :as t]))


  <<spheres_create>>

  <<spheres_ray_int>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/spheres_test.clj
  (ns rt-clj.spheres-test
    (:require [clojure.test :refer :all]
              [rt-clj.spheres :refer :all]
              [rt-clj.matrices :as m]
              [rt-clj.rays :as r]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]))

  (deftest spheres-test
    <<spheres_ray_int_test>>

    <<spheres_trans_test>>

    <<spheres_int_trans_test>>)
  #+END_SRC

* Example

  Let's draw a sphere, in =[0. 0. 0.]=, scaled by a factor =0.5= in the =y= direction.

  The rays origin is in =[3. 0. 0.]= and the projection screen is the plane =[-3. y z]=.

  Pixels will be black if the ray misses, red if the ray hits the sphere.

  #+BEGIN_SRC clojure :exports code :results output :file ../samples/sphere_ray_example.ppm
  (require '[rt-clj.canvas :as ca])
  (require '[rt-clj.colors :as co])
  (require '[rt-clj.intersections :as in])
  (require '[rt-clj.rays :as ra])
  (require '[rt-clj.spheres :as sp])
  (require '[rt-clj.transformations :as tr])
  (require '[rt-clj.tuples :as tu])

  (let [miss-col (co/color 0. 0. 0.)
        hit-col (co/color 1. 0. 0.)
        s (sp/sphere (tr/scaling 1. 0.5 1.))
        o (tu/point 3. 0. 0.)
        h 256
        w 256
        sc-min -3.
        sc-max 3.
        sc-width (- sc-max sc-min)
        pixel-step-w (/ sc-width w)
        pixel-step-h (/ sc-width h)
        hits (mapv (fn[i]
                     (mapv (fn [j]
                             (let [screen-p (tu/point -3.
                                                      (+ -3. (* i pixel-step-w))
                                                      (+ -3. (* j pixel-step-h)))
                                   ray-d (tu/sub screen-p o)
                                   ray (ra/ray o ray-d)]
                               (in/hit (sp/intersect s ray)))) (range w))) (range h))
        cv (reduce (fn [c i]
                     (reduce (fn [c j]
                               (ca/assoc-at c i j (if (get-in hits [i j])
                                                    hit-col
                                                    miss-col)))
                             c (range w)))
                   (ca/canvas w h) (range h))]
    ;; print the PPM file
    (println
      (clojure.string/join "\n" (ca/ppm-rows cv))))
  #+END_SRC

  [[file:../samples/sphere_ray_example.png]]
