#+TITLE: 07 - Spheres
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

Let's draw a sphere, in =[0. 0. 0.]=, scaled by a factor =0.5= in the =y= direction.

The rays origin is in =[3. 0. 0.]= and the projection screen is the plane =[-3. y z]=.

Pixels will be black if the ray misses, red if the ray hits the sphere.

[[file:../samples/sphere_ray_example.png]]

* Creation

  Spheres are record implementing Shape protocol.

  #+NAME: spheres_create
  #+BEGIN_SRC clojure
  (defrecord Sphere [material transform inverse-t trans-inverse-t]
    sh/Shape
    (sh/intersect [sh ray]
      (sh/intersect' sh ray local-intersect))
    (sh/normal [sh world-p]
      (sh/normal' sh world-p local-normal)))

  (defn sphere
    ([transform material]
     (let [inverse-t (m/inverse transform)]
       (map->Sphere
         {:material material
          :transform transform
          :inverse-t inverse-t
          :trans-inverse-t (m/transpose inverse-t)})))
    ([transform]
     (sphere transform mr/default-material))
    ([]
     (sphere (m/id 4) mr/default-material)))
  #+END_SRC

  Spheres have a transform property.

  #+NAME: spheres_trans_test
  #+BEGIN_SRC clojure
  (testing "A sphere's default transformation"
    (is (= (m/id 4)
           (:transform (sphere)))))

  (testing "Changing a sphere's transformation"
    (let [t (tr/translation 2. 3. 4.)
          s (sphere t)]
      (:transform s)))
  #+END_SRC

  Spheres has a material property.

  #+NAME: spheres_material_test
  #+BEGIN_SRC clojure
  (testing "A sphere has a default material"
    (is (= mr/default-material
           (:material (sphere)))))
  #+END_SRC

* Intersections

  A ray aways interesects a sphere at 2 points, even when tangent, or it totally misses the sphere.
  - when a ray is tangent to a sphere, both distances are equals.
  - when the ray originates inside a sphere, one of the distance is negative.
  - when the sphere is behing the ray's origin, both distances are negatives.
  The first intersection distance is always the smallest.

  #+NAME: spheres_ray_int_test
  #+BEGIN_SRC clojure
  (testing "A ray intersects a sphere at two points"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (sh/intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= 4.
             (:t (first xs))))
      (is (= 6.
             (:t (second xs))))))

  (testing "A ray intersects a sphere at a tangent"
    (let [ra (r/ray (t/point 0. 1. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (sh/intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= 5.
             (:t (first xs))))
      (is (= 5.
             (:t (second xs))))))

  (testing "A ray misses a sphere"
    (let [ra (r/ray (t/point 0. 2. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (sh/intersect s ra)]
      (is (= 0
             (count xs)))))

  (testing "A ray originates inside a sphere"
    (let [ra (r/ray (t/point 0. 0. 0.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (sh/intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= -1.
             (:t (first xs))))
      (is (= 1.
             (:t (second xs))))))

  (testing "A sphere is behind a ray"
    (let [ra (r/ray (t/point 0. 0. 5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (sh/intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= -6.
             (:t (first xs))))
      (is (= -4.
             (:t (second xs))))))

  (testing "Intersect sets the object on the intersection"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere)
          xs (sh/intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= s
             (:object (first xs))))
      (is (= s
             (:object (second xs))))))
  #+END_SRC

  #+NAME: spheres_ray_int
  #+BEGIN_SRC clojure
  (defn- local-intersect [s {:keys [origin direction]}]
    (let [s->ra (t/sub origin t/origin)
          two-a (* (t/dot direction direction) 2)
          b (* 2 (t/dot direction s->ra))
          c (- (t/dot s->ra s->ra) 1)
          discriminant (- (* b b) (* 2 two-a c))]
      (if (< discriminant 0)
        []
        (let [s-d (Math/sqrt discriminant)
              t1 (/ (- 0 s-d b) two-a)
              t2 (/ (- s-d b) two-a)
              i1 (i/intersection t1 s)
              i2 (i/intersection t2 s)]
          (if (< t1 t2)
            (i/intersections i1 i2)
            (i/intersections i2 i1))))))
  #+END_SRC

  Transformations of the spheres are applied to the ray when calculating the intersections.

  #+NAME: spheres_int_trans_test
  #+BEGIN_SRC clojure
  (testing "Intersecting a scaled sphere with a ray"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere (tr/scaling 2. 2. 2.))
          xs (sh/intersect s ra)]
      (is (= 2
             (count xs)))
      (is (= 3.
             (:t (first xs))))
      (is (= 7.
             (:t (second xs))))))

  (testing "Intersecting a translated sphere with a ray"
    (let [ra (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          s (sphere (tr/translation 5. 0. 0.))
          xs (sh/intersect s ra)]
      (is (= 0
             (count xs)))))
  #+END_SRC

* Normal

  Normal is easy to calculate since the sphere is always centered at the origin.

  #+NAME: spheres_norm_test
  #+BEGIN_SRC clojure
  (testing "The normal on a sphere at a point on the x axis"
    (is (= (t/vector 1. 0. 0.)
           (sh/normal (sphere) (t/point 1. 0. 0.)))))

  (testing "The normal on a sphere at a point on the y axis"
    (is (= (t/vector 0. 1. 0.)
           (sh/normal (sphere) (t/point 0. 1. 0.)))))

  (testing "The normal on a sphere at a point on the z axis"
    (is (= (t/vector 0. 0. 1.)
           (sh/normal (sphere) (t/point 0. 0. 1.)))))

  (testing "The normal on a sphere at a non-axial point"
    (let [p (/ (Math/sqrt 3.) 3.)]
      (is (= (t/vector p p p)
             (sh/normal (sphere) (t/point p p p))))))
  #+END_SRC

  But we must also take into account the sphere's transformation.

  #+NAME: spheres_norm_trans_test
  #+BEGIN_SRC clojure
  (testing "Computing the normal on a translated sphere"
    (is (t/eq? (t/vector 0. 0.70711 -0.70711)
               (sh/normal (sphere (tr/translation 0. 1. 0.))
                          (t/point 0, 1.70711, -0.70711)))))

  (testing "Computing the normal on a scaled sphere"
    (is (t/eq? (t/vector 0. 0.97014 -0.24254)
               (sh/normal (sphere (tr/scaling 1. 0.5 1.))
                          (t/point 0, 0.70711, -0.70711)))))
  #+END_SRC

  #+NAME: spheres_norm
  #+BEGIN_SRC clojure
  (defn- local-normal [_ object-p]
    (t/sub object-p t/origin))
  #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/spheres.clj
  (ns rt-clj.spheres
    (:require [rt-clj.intersections :as i]
              [rt-clj.materials :as mr]
              [rt-clj.matrices :as m]
              [rt-clj.rays :as r]
              [rt-clj.shapes :as sh]
              [rt-clj.tuples :as t]))


  <<spheres_ray_int>>


  <<spheres_norm>>


  <<spheres_create>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/spheres_test.clj
  (ns rt-clj.spheres-test
    (:require [clojure.test :refer :all]
              [rt-clj.spheres :refer :all]
              [rt-clj.intersections :as i]
              [rt-clj.materials :as mr]
              [rt-clj.matrices :as m]
              [rt-clj.rays :as r]
              [rt-clj.shapes :as sh]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]))

  (deftest spheres-test
    <<spheres_trans_test>>

    <<spheres_material_test>>

    <<spheres_ray_int_test>>

    <<spheres_int_trans_test>>

    <<spheres_norm_test>>

    <<spheres_norm_trans_test>>)
  #+END_SRC

