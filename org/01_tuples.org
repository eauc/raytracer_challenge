#+TITLE: 01 - Tuples
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Points & Vectors

  Tuples are used to represent vectors and points.

  Each tuples starts with 3 spatial coordinates =x,y,z=, and then a 4th coordinate =w= indicates whether the tuple is a point or a vector.

  #+BEGIN_SRC clojure
  ;; point w = 1
  (1 2 4 1)

  ;; vector w = 0
  (1 2 4 0)
  #+END_SRC

  We can create tuples, access their coordinates, and check whether they are points or vectors.

  #+NAME: tuples_create_test
  #+BEGIN_SRC clojure
  (testing "A tuple with w=1.0 is a point"
    (let [tup (tuple 4.1 -4.2 3.1 1.0)]
      (is (= 4.1
             (x tup)))
      (is (= -4.2
             (y tup)))
      (is (= 3.1
             (z tup)))
      (is (= 1.0
             (w tup)))
      (is (= true
             (point? tup)) "is point")
      (is (= false
             (vector? tup)) "is not vector")))


  (testing "A tuple with w=0.0 is a vector"
    (let [tup (tuple 4.1 -4.2 3.1 0.0)]
      (is (= 4.1
             (x tup)))
      (is (= -4.2
             (y tup)))
      (is (= 3.1
             (z tup)))
      (is (= 0.0
             (w tup)))
      (is (= false
             (point? tup)) "is not point")
      (is (= true
             (vector? tup)) "is vector")))
  #+END_SRC

  We can also create point and vectors directly.

  #+NAME: tuples_create_point_vector_test
  #+BEGIN_SRC clojure
  (testing "'point' create a tuple with w=1.0"
    (is (= (tuple 4.1 -4.2 3.1 1.0)
           (point 4.1 -4.2 3.1))))


  (testing "'vector' create a tuple with w=0.0"
    (is (= (tuple 4.1 -4.2 3.1 0.0)
           (vector 4.1 -4.2 3.1))))
  #+END_SRC

  Tuples are simple clojure vectors.

  #+NAME: tuples_create
  #+BEGIN_SRC clojure
  (def tuple clojure.core/vector)

  (def x first)

  (def y second)

  (def z #(nth % 2))

  (def w #(nth % 3))

  (defn point? [tup]
    (= 1.0 (w tup)))

  (defn vector? [tup]
    (= 0.0 (w tup)))

  (defn point [x y z]
    (tuple x y z 1.0))

  (defn vector [x y z]
    (tuple x y z 0.0))

  (def origin (point 0. 0. 0.))

  (def zerov (vector 0. 0. 0.))
  #+END_SRC

* Operations

  Tuples support basic addition & substraction.

  #+NAME: tuples_add_sub_test
  #+BEGIN_SRC clojure
  (testing "Adding a point and a vector gives a point"
    (is (eq? (point 1 1 6)
             (add (point 3 -2 5)
                  (vector -2 3 1)))))


  (testing "Adding 2 vectors gives a vector"
    (is (eq? (vector 1 1 6)
             (add (vector 3 -2 5)
                  (vector -2 3 1)))))


  (testing "Adding 2 points does not make sense"
    (is (eq? (tuple 1 1 6 2.0)
             (add (point 3 -2 5)
                  (point -2 3 1)))))


  (testing "Substracting 2 points gives a vector"
    (is (eq? (vector -2 -4 -6)
             (sub (point 3 2 1)
                  (point 5 6 7)))))


  (testing "Substracting a vector from a point gives a point"
    (is (eq? (point -2 -4 -6)
             (sub (point 3 2 1)
                  (vector 5 6 7)))))


  (testing "Substracting 2 vectors gives a vector"
    (is (eq? (vector -2 -4 -6)
             (sub (vector 3 2 1)
                  (vector 5 6 7)))))


  (testing "Substracting a point from a vector makes no sense"
    (is (eq? (tuple -2 -4 -6 -1.0)
             (sub (vector 3 2 1)
                  (point 5 6 7)))))
  #+END_SRC

  Vectors can be negated, multiplied and divided by scalars.

  #+NAME: tuples_neg_mul_div_test
  #+BEGIN_SRC clojure
  (testing "Negating a vector gives a vector"
    (is (eq? (vector -3 -2 -1)
             (neg (vector 3 2 1)))))


  (testing "Negating a points makes no sense"
    (is (eq? (tuple -3 -2 -1 -1.0)
             (neg (point 3 2 1)))))


  (testing "Multiplying a vector by a scalar gives a vector"
    (is (eq? (vector 3.5 -7.0 10.5)
             (mul (vector 1 -2 3) 3.5))))


  (testing "Multiplying a point by a scalar does not make sense"
    (is (eq? (tuple 3.5 -7.0 10.5 3.5)
             (mul (point 1 -2 3) 3.5))))


  (testing "Dividing a vector by a scalar gives a vector"
    (is (eq? (vector 0.5 -1.0 1.5)
             (div (vector 1.0 -2.0 3.0) 2))))


  (testing "Dividing a point by a scalar does not make sense"
    (is (eq? (tuple 0.5 -1.0 1.5 0.5)
             (div (point 1.0 -2.0 3.0) 2))))
  #+END_SRC

  We can get the magnitude of a vector.

  #+NAME: tuples_mag_test
  #+BEGIN_SRC clojure
  (testing "Magnitude"
    (is (= 1.0
           (mag (vector 1.0 0.0 0.0))))
    (is (= 1.0
           (mag (vector 0.0 1.0 0.0))))
    (is (= 1.0
           (mag (vector 0.0 0.0 1.0))))
    (is (= (Math/sqrt 14.0)
           (mag (vector 1.0 2.0 3.0))))
    (is (= (Math/sqrt 14.0)
           (mag (vector -1.0 -2.0 -3.0)))))
  #+END_SRC

  We can normalize a vector.

  #+NAME: tuples_norm_test
  #+BEGIN_SRC clojure
  (testing "Normalize"
    (is (eq? (vector 1.0 0.0 0.0)
             (norm (vector 4.0 0.0 0.0))))
    (is (eq? (vector (/ 1.0 (Math/sqrt 14)) (/ 2.0 (Math/sqrt 14)) (/ 3.0 (Math/sqrt 14)))
             (norm (vector 1.0 2.0 3.0)))))
  #+END_SRC

  We can get the dot and cross products of vectors.

  #+NAME: tuples_dot_cross_test
  #+BEGIN_SRC clojure
  (testing "Dot product"
    (is (= 20.0
           (dot (vector 1.0 2.0 3.0)
                (vector 2.0 3.0 4.0)))))


  (testing "Cross product"
    (is (eq? (vector -1.0 2.0 -1.0)
             (cross (vector 1.0 2.0 3.0)
                    (vector 2.0 3.0 4.0))))
    (is (eq? (vector 1.0 -2.0 1.0)
             (cross (vector 2.0 3.0 4.0)
                    (vector 1.0 2.0 3.0)))))
  #+END_SRC

  Here are the basic operations definitions.

  #+NAME: tuples_operations
  #+BEGIN_SRC clojure
  (def add (partial mapv +))

  (def sub (partial mapv -))

  (def neg (partial sub zerov))

  (defn mul [v s]
    (mapv #(* % s) v))

  (defn div [v s]
    (mapv #(/ % s) v))

  (defn dot [v w]
    (reduce + (map * v w)))

  (defn mag [v]
    (Math/sqrt (dot v v)))

  (defn norm [v]
    (div v (mag v)))

  (defn cross [[x1 y1 z1]
               [x2 y2 z2]]
    (vector (- (* y1 z2)
               (* y2 z1))
            (- (* z1 x2)
               (* z2 x1))
            (- (* x1 y2)
               (* x2 y1))))
  #+END_SRC

* Equality

  We need to define close equality for 2 floating-point scalars.

  #+NAME: tuples_close
  #+BEGIN_SRC clojure
  (def epsilon 10e-6)

  (defn close? [a b]
    (> epsilon (Math/abs (- a b))))
  #+END_SRC

  Then we need close equality of 2 tuples.

  #+NAME: tuples_eq
  #+BEGIN_SRC clojure
  (defn eq? [a b]
    (every? true? (map close? a b)))
  #+END_SRC

* Reflection

  Vectors can be reflected on a surface defined by a normal.

  #+NAME: tuples_reflect_test
  #+BEGIN_SRC clojure
  (testing "Reflecting a vector approaching at 45Â°"
    (is (eq? (vector 1. 1. 0.)
             (reflect (vector 1. -1. 0.) (vector 0. 1. 0.)))))

  (testing "Reflecting a vector off a slanted surface"
    (let [d (/ (Math/sqrt 2.) 2.)]
      (is (eq? (vector 1. 0. 0.)
               (reflect (vector 0. -1. 0.) (vector d d 0.))))))
  #+END_SRC

  #+NAME: tuples_reflect
  #+BEGIN_SRC clojure
  (defn reflect [in normal]
    (sub in (mul normal (* 2 (dot in normal)))))
  #+END_SRC

* Files                                                           :noexport:
   :PROPERTIES:
   :header-args: :exports none :noweb yes
   :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/tuples.clj
  (ns rt-clj.tuples
    (:import java.lang.Math)
    (:refer-clojure :exclude [vector vector?]))


  <<tuples_create>>


  <<tuples_close>>

  <<tuples_eq>>

  <<tuples_operations>>

  <<tuples_reflect>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/tuples_test.clj
  (ns rt-clj.tuples-test
    (:import java.lang.Math)
    (:refer-clojure :exclude [vector vector?])
    (:require [clojure.test :refer :all]
              [rt-clj.tuples :refer :all]))

  (deftest tuples-test
    <<tuples_create_test>>

    <<tuples_create_point_vector_test>>

    <<tuples_add_sub_test>>

    <<tuples_neg_mul_div_test>>

    <<tuples_mag_test>>

    <<tuples_norm_test>>

    <<tuples_dot_cross_test>>

    <<tuples_reflect_test>>)
  #+END_SRC
