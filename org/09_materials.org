#+TITLE: 09 - Materials
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Creation

  #+NAME: materials_create_test
  #+BEGIN_SRC clojure
  (testing "The default material"
    (let [m (material)]
      (is (= (c/color 1. 1. 1.)
             (:color m)))
      (is (= 0.1
             (:ambient m)))
      (is (= 0.9
             (:diffuse m)))
      (is (= 0.9
             (:specular m)))
      (is (= 200
             (:shininess m)))))
  #+END_SRC

  #+NAME: materials_create
  #+BEGIN_SRC clojure
  (defn material []
    {:color (c/color 1. 1. 1.)
     :ambient 0.1
     :diffuse 0.9
     :specular 0.9
     :shininess 200})
  #+END_SRC

* Lighting

  The Phong reflection model:
  - Ambient reflection is background lighting.
  - Diffuse reflection is light reflected from a matte surface.
  - Specular reflection is the reflection of the light source itself.

  #+NAME: materials_lighting_test
  #+BEGIN_SRC clojure
  (let [m (material)
        position (t/point 0. 0. 0.)
        pi-4 (/ (Math/sqrt 2) 2)]
    (testing "Lighting with the eye between the light and the surface"
      (let [eyev (t/vector 0. 0. -1.)
            normalv (t/vector 0. 0. -1.)
            light (l/point-light (t/point 0. 0. -10.) (c/color 1. 1. 1.))]
        (is (t/eq? (c/color 1.9 1.9 1.9)
                   (lighting m light position eyev normalv)))))

    (testing "Lighting with the eye between light and surface, eye offset 45°"
      (let [eyev (t/vector 0. pi-4 (- 0 pi-4))
            normalv (t/vector 0. 0. -1.)
            light (l/point-light (t/point 0. 0. -10.) (c/color 1. 1. 1.))]
        (is (t/eq? (c/color 1. 1. 1.)
                   (lighting m light position eyev normalv)))))

    (testing "Lighting with eye opposite surface, light offset 45°"
      (let [eyev (t/vector 0. 0. -1.)
            normalv (t/vector 0. 0. -1.)
            light (l/point-light (t/point 0. 10. -10.) (c/color 1. 1. 1.))]
        (is (t/eq? (c/color 0.7364 0.7364 0.7364)
                   (lighting m light position eyev normalv)))))

    (testing "Lighting with eye in the path of the reflection vector"
      (let [eyev (t/vector 0. (- 0 pi-4) (- 0 pi-4))
            normalv (t/vector 0. 0. -1.)
            light (l/point-light (t/point 0. 10. -10.) (c/color 1. 1. 1.))]
        (is (t/eq? (c/color 1.6364 1.6364 1.6364)
                   (lighting m light position eyev normalv)))))

    (testing "Lighting with the light behind the surface"
      (let [eyev (t/vector 0. 0. -1.)
            normalv (t/vector 0. 0. -1.)
            light (l/point-light (t/point 0. 0. 10.) (c/color 1. 1. 1.))]
        (is (t/eq? (c/color 0.1 0.1 0.1)
                   (lighting m light position eyev normalv))))))
  #+END_SRC

  #+NAME: materials_lighting
  #+BEGIN_SRC clojure
  (defn lighting [material light position eyev normalv]
    (let [effective-color (c/dot (:color material) (:intensity light))
          lightv (t/norm (t/sub (:position light) position))
          ambient (c/mul effective-color (:ambient material))
          light-dot-normal (t/dot lightv normalv)]
      (if (> 0 light-dot-normal)
        ambient
        (let [diffuse (c/mul effective-color (* (:diffuse material) light-dot-normal))
              reflectv (t/reflect (t/sub (t/vector 0. 0. 0.) lightv) normalv)
              reflect-dot-eyev' (t/dot reflectv eyev)
              reflect-dot-eyev (Math/pow reflect-dot-eyev' (:shininess material))
              amb-dif (c/add ambient diffuse)]
          (if (> 0 reflect-dot-eyev)
            amb-dif
            (let [specular (c/mul (:intensity light) (* reflect-dot-eyev (:specular material)))]
              (c/add amb-dif specular)))))))
  #+END_SRC

* Files                                                           :noexport:
   :PROPERTIES:
   :header-args: :exports none :noweb yes
   :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/materials.clj
  (ns rt-clj.materials
    (:require [rt-clj.colors :as c]
              [rt-clj.tuples :as t]))


  <<materials_create>>

  <<materials_lighting>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/materials_test.clj
  (ns rt-clj.materials-test
    (:import java.lang.Math)
    (:require [clojure.test :refer :all]
              [rt-clj.materials :refer :all]
              [rt-clj.colors :as c]
              [rt-clj.lights :as l]
              [rt-clj.tuples :as t]))

  (deftest materials-test
    <<materials_create_test>>

    <<materials_lighting_test>>)
  #+END_SRC

* Example

  Let's draw a sphere, in =[0. 0. 0.]=, scaled by a factor =0.5= in the =z= direction.

  The rays origin is in =[3. 0. 0.]= and the projection screen is the plane =[-3. y z]=.

  A light source is behind the eye to the upper right at =[10. 10. -10.]=

  The sphere is purple and we will use our material lighting.

  #+BEGIN_SRC clojure :exports code :tangle ../dev/rt_clj/sphere_light_example.clj
  (ns rt-clj.sphere-light-example
    (:require [rt-clj.canvas :as ca]
              [rt-clj.colors :as co]
              [rt-clj.intersections :as in]
              [rt-clj.lights :as li]
              [rt-clj.materials :as mr]
              [rt-clj.rays :as ra]
              [rt-clj.spheres :as sp]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as tu]))

  (comment
    (let [miss-col (co/color 0. 0. 0.)
          l (li/point-light (tu/point 10. 10. -10.) (co/color 1. 1. 1.))
          m (-> (mr/material)
                (assoc :color (co/color 1. 0.2 1.)))
          s (-> (sp/sphere (tr/scaling 1. 1. 0.5))
                (assoc :material m))
          e (tu/point 3. 0. 0.)
          h 512
          w 512
          sc-min -3.
          sc-max 3.
          sc-width (- sc-max sc-min)
          pixel-step-w (/ sc-width w)
          pixel-step-h (/ sc-width h)
          pixel (fn [i j]
                  (let [screen-p (tu/point -3.
                                           (+ -3. (* i pixel-step-w))
                                           (+ -3. (* j pixel-step-h)))
                        ray-d (tu/norm (tu/sub screen-p e))
                        ray (ra/ray e ray-d)
                        hit? (in/hit (sp/intersect s ray))]
                    (if (nil? hit?)
                      miss-col
                      (let [position (ra/pos ray (:t hit?))
                            normal (sp/normal-at s position)]
                        (mr/lighting m l position ray-d normal)))))
          pixs (mapv (fn[i]
                       (mapv (fn [j]
                               (pixel i j))
                             (range w)))
                     (range h))
          cv (reduce (fn [c i]
                       (reduce (fn [c j]
                                 (ca/assoc-at c i j (get-in pixs [i j])))
                               c (range w)))
                     (ca/canvas w h) (range h))]
      ;; print the PPM file
      (spit "./samples/sphere_light_example.ppm"
        (clojure.string/join "\n" (ca/ppm-rows cv)))))
  #+END_SRC

  [[file:../samples/sphere_light_example.png]]
