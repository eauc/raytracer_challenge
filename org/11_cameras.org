#+TITLE: 11 - Cameras
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

[[file:../samples/camera_world_example.png]]

* Creation

  Cameras are defined by:
  - a width in pixels.
  - a height in pixels.
  - a field of view in radians.

  #+NAME: cameras_create_test
  #+BEGIN_SRC clojure
  (testing "Constructing a camera"
    (let [cam (camera 160 120 (/ Math/PI 2))]
      (is (= 160
             (:hsize cam)))
      (is (= 120
             (:vsize cam)))
      (is (= (/ Math/PI 2)
             (:fov cam)))
      (is (= (m/id 4)
             (:transform cam)))))
  #+END_SRC

  We can access the size of each pixels, computed from the greatest of hsize & vsize, and the field of view.

  #+NAME: cameras_psize_test
  #+BEGIN_SRC clojure
  (testing "The pixel size for a horizontal canvas"
    (is (t/close? 0.01
                  (:pixel-size (camera 200. 125. (/ Math/PI 2))))))

  (testing "The pixel size for a horizontal canvas"
    (is (t/close? 0.01
                  (:pixel-size (camera 125. 200. (/ Math/PI 2))))))
  #+END_SRC

  #+NAME: cameras_create
  #+BEGIN_SRC clojure
  (defn camera
    ([hs vs fov transform]
     (let [half-view (Math/tan (/ fov 2.))
           aspect (/ hs vs)
           half-width (if (>= aspect 1) half-view (* half-view aspect))
           half-height (if (>= aspect 1) (/ half-view aspect) half-view)
           pixel-size (/ (* half-width 2) hs)]
       {:hsize hs
        :vsize vs
        :fov fov
        :transform transform
        :inverse-t (m/inverse transform)
        :half-width half-width
        :half-height half-height
        :pixel-size pixel-size}))
    ([hs vs fov]
     (camera hs vs fov (m/id 4))))
  #+END_SRC

* Rays

  We can construct rays from the camera "eye" to any pixel in the field of view.
  - first we compute the coordinates of the pixel in camera coordinates.
  - then we transform the pixel and the origin into world coordinates.
  - the ray's origin is the world origin.
  - the ray's direction is the vector from the world-origin to the world-pixel.

  #+NAME: cameras_rays_test
  #+BEGIN_SRC clojure
  (testing "Construct a ray through the center of the canvas"
    (let [cam (camera 201. 101 (/ Math/PI 2))
          ray (pixel-ray cam 100 50)]
      (is (= (t/point 0. 0. 0.)
             (:origin ray)))
      (is (t/eq? (t/vector 0. 0. -1.)
                 (:direction ray)))))

  (testing "Construct a ray through a corner of the canvas"
    (let [cam (camera 201. 101 (/ Math/PI 2))
          ray (pixel-ray cam 0 0)]
      (is (= (t/point 0. 0. 0.)
             (:origin ray)))
      (is (t/eq? (t/vector 0.66519 0.33259 -0.66851)
                 (:direction ray)))))

  (testing "Construct a ray when the camera is transformed"
    (let [cam (camera 201. 101 (/ Math/PI 2)
                      (m/mul (tr/rotation-y (/ Math/PI 4))
                             (tr/translation 0. -2. 5.)))
          ray (pixel-ray cam 100 50)]
      (is (= (t/point 0. 2. -5.)
             (:origin ray)))
      (is (t/eq? (t/vector (/ (Math/sqrt 2) 2) 0. (- (/ (Math/sqrt 2) 2)))
                 (:direction ray)))))
  #+END_SRC

  #+NAME: cameras_rays
  #+BEGIN_SRC clojure
  (defn pixel-ray [{:keys [half-width half-height pixel-size inverse-t]} px py]
    (let [cam-x (- half-width (* (+ px 0.5) pixel-size))
          cam-y (- half-height (* (+ py 0.5) pixel-size))
          world-pixel (m/mul inverse-t (t/point cam-x cam-y -1.))
          world-origin (m/mul inverse-t t/origin)
          direction (t/norm (t/sub world-pixel world-origin))]
      (r/ray world-origin direction)))
  #+END_SRC

* World

  We can render a world as seen from a camera.

  #+NAME: cameras_world_test
  #+BEGIN_SRC clojure
  (testing "Rendering a world with a camera"
    (let [world w/default-world
          cam (camera 11. 11. (/ Math/PI 2)
                      (tr/view (t/point 0. 0. -5.)
                               (t/point 0. 0. 0.)
                               (t/vector 0. 1. 0.)))]
      (is (t/eq? (co/color 0.38066, 0.47583, 0.2855)
                 (ca/get-at (render cam world) 5 5)))))
  #+END_SRC

  #+NAME: cameras_world
  #+BEGIN_SRC clojure
  (def default-depth 4)

  (defn render
    ([{:keys [hsize vsize] :as cam} world
      {:keys [parallel?] :as options
       :or {parallel? true}}]
     (if parallel?
       (cr/fold
         (int (/ vsize 8))
         (fn combinef
           ([] [])
           ([a b] (concat a b)))
         (fn reducef
           ([] [])
           ([cs y]
            (conj cs (mapv #(w/color world (pixel-ray cam % y) default-depth)
                           (vec (range hsize))))))
         (vec (range vsize)))
       (mapv (fn [y]
               (mapv #(w/color world (pixel-ray cam % y) default-depth)
                     (range hsize)))
             (range vsize))))
    ([cam world]
     (render cam world {})))
  #+END_SRC

* Files                                                           :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/cameras.clj
  (ns rt-clj.cameras
    (:import java.lang.Math)
    (:require [clojure.core.reducers :as cr]
              [rt-clj.canvas :as ca]
              [rt-clj.matrices :as m]
              [rt-clj.rays :as r]
              [rt-clj.tuples :as t]
              [rt-clj.worlds :as w]))


  <<cameras_create>>


  <<cameras_rays>>


  <<cameras_world>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/cameras_test.clj
  (ns rt-clj.cameras-test
    (:require [clojure.test :refer :all]
              [rt-clj.cameras :refer :all]
              [rt-clj.canvas :as ca]
              [rt-clj.colors :as co]
              [rt-clj.matrices :as m]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]
              [rt-clj.worlds :as w]))

  (deftest cameras-test
    <<cameras_create_test>>

    <<cameras_psize_test>>

    <<cameras_rays_test>>

    <<cameras_world_test>>)
  #+END_SRC
