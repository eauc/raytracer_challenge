#+TITLE: 11 - Cameras
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Creation

  Cameras are defined by:
  - a width in pixels.
  - a height in pixels.
  - a field of view in radians.

  #+NAME: cameras_create_test
  #+BEGIN_SRC clojure
  (testing "Constructing a camera"
    (let [cam (camera 160 120 (/ Math/PI 2))]
      (is (= 160
             (:hsize cam)))
      (is (= 120
             (:vsize cam)))
      (is (= (/ Math/PI 2)
             (:fov cam)))
      (is (= (m/id 4)
             (:transform cam)))))
  #+END_SRC

  We can access the size of each pixels, computed from the greatest of hsize & vsize, and the field of view.

  #+NAME: cameras_psize_test
  #+BEGIN_SRC clojure
  (testing "The pixel size for a horizontal canvas"
    (:pixel-size (camera 200. 125. (/ Math/PI 2))))

  (testing "The pixel size for a horizontal canvas"
    (:pixel-size (camera 125. 200. (/ Math/PI 2))))
  #+END_SRC

  #+NAME: cameras_create
  #+BEGIN_SRC clojure
  (defn camera
    ([hs vs fov transform]
     (let [half-view (Math/tan (/ fov 2.))
           aspect (/ hs vs)
           half-width (if (>= aspect 1) half-view (* half-view aspect))
           half-height (if (>= aspect 1) (/ half-view aspect) half-view)
           pixel-size (/ (* half-width 2) hs)]
       {:hsize hs
        :vsize vs
        :fov fov
        :transform transform
        :inverse-t (m/inverse transform)
        :half-width half-width
        :half-height half-height
        :pixel-size pixel-size}))
    ([hs vs fov]
     (camera hs vs fov (m/id 4))))
  #+END_SRC

* Rays

  We can construct rays from the camera "eye" to any pixel in the field of view.
  - first we compute the coordinates of the pixel in camera coordinates.
  - then we transform the pixel and the origin into world coordinates.
  - the ray's origin is the world origin.
  - the ray's direction is the vector from the world-origin to the world-pixel.

  #+NAME: cameras_rays_test
  #+BEGIN_SRC clojure
  (testing "Construct a ray through the center of the canvas"
    (let [cam (camera 201. 101 (/ Math/PI 2))
          ray (pixel-ray cam 100 50)]
      (is (= (t/point 0. 0. 0.)
             (:origin ray)))
      (is (t/eq? (t/vector 0. 0. -1.)
                 (:direction ray)))))

  (testing "Construct a ray through a corner of the canvas"
    (let [cam (camera 201. 101 (/ Math/PI 2))
          ray (pixel-ray cam 0 0)]
      (is (= (t/point 0. 0. 0.)
             (:origin ray)))
      (is (t/eq? (t/vector 0.66519 0.33259 -0.66851)
                 (:direction ray)))))

  (testing "Construct a ray when the camera is transformed"
    (let [cam (camera 201. 101 (/ Math/PI 2)
                      (m/mul (tr/rotation-y (/ Math/PI 4))
                             (tr/translation 0. -2. 5.)))
          ray (pixel-ray cam 100 50)]
      (is (= (t/point 0. 2. -5.)
             (:origin ray)))
      (is (t/eq? (t/vector (/ (Math/sqrt 2) 2) 0. (- (/ (Math/sqrt 2) 2)))
                 (:direction ray)))))
  #+END_SRC

  #+NAME: cameras_rays
  #+BEGIN_SRC clojure
  (defn pixel-ray [{:keys [half-width half-height pixel-size inverse-t]} px py]
    (let [cam-x (- half-width (* (+ px 0.5) pixel-size))
          cam-y (- half-height (* (+ py 0.5) pixel-size))
          world-pixel (m/mul inverse-t (t/point cam-x cam-y -1.))
          world-origin (m/mul inverse-t t/origin)
          direction (t/norm (t/sub world-pixel world-origin))]
      (r/ray world-origin direction)))
  #+END_SRC

* World

  We can render a world as seen from a camera.

  #+NAME: cameras_world_test
  #+BEGIN_SRC clojure
  (testing "Rendering a world with a camera"
    (let [world w/default-world
          cam (camera 11. 11. (/ Math/PI 2)
                      (tr/view (t/point 0. 0. -5.)
                               (t/point 0. 0. 0.)
                               (t/vector 0. 1. 0.)))]
      (is (t/eq? (co/color 0.38066, 0.47583, 0.2855)
                 (ca/get-at (render cam world) 5 5)))))
  #+END_SRC

  #+NAME: cameras_world
  #+BEGIN_SRC clojure
  (defn render [{:keys [hsize vsize] :as cam} world]
    (reduce
      (fn [image y]
        (reduce
          (fn [image x]
            (ca/assoc-at image x y (w/color world (pixel-ray cam x y))))
          image (range hsize)))
      (ca/canvas hsize vsize) (range vsize)))
  #+END_SRC

* Files                                                           :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/cameras.clj
  (ns rt-clj.cameras
    (:import java.lang.Math)
    (:require [rt-clj.canvas :as ca]
              [rt-clj.matrices :as m]
              [rt-clj.rays :as r]
              [rt-clj.tuples :as t]
              [rt-clj.worlds :as w]))


  <<cameras_create>>


  <<cameras_rays>>


  <<cameras_world>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/cameras_test.clj
  (ns rt-clj.cameras-test
    (:require [clojure.test :refer :all]
              [rt-clj.cameras :refer :all]
              [rt-clj.canvas :as ca]
              [rt-clj.colors :as co]
              [rt-clj.matrices :as m]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]
              [rt-clj.worlds :as w]))

  (deftest cameras-test
    <<cameras_create_test>>

    <<cameras_psize_test>>

    <<cameras_rays_test>>

    <<cameras_world_test>>)
  #+END_SRC
* Example

  #+BEGIN_SRC clojure :exports code :tangle ../dev/rt_clj/camera_world_example.clj
  (ns rt-clj.camera-world-example
    (:require [rt-clj.cameras :as cm]
              [rt-clj.canvas :as ca]
              [rt-clj.colors :as co]
              [rt-clj.intersections :as in]
              [rt-clj.lights :as li]
              [rt-clj.matrices :as ma]
              [rt-clj.materials :as mr]
              [rt-clj.rays :as ra]
              [rt-clj.spheres :as sp]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as tu]
              [rt-clj.worlds :as wo]))

  (comment
    (let [w-material (-> (mr/material)
                         (assoc :color (co/color 1. 0.9 0.9)
                                :specular 0.))
          floor (sp/sphere (tr/scaling 10. 0.01 10.)
                           w-material)
          left-wall (sp/sphere (ma/mul
                                 (tr/translation 0. 0. 5.)
                                 (ma/mul
                                   (tr/rotation-y (- (/ Math/PI 4)))
                                   (ma/mul
                                     (tr/rotation-x (/ Math/PI 2))
                                     (tr/scaling 10. 0.01 10.))))
                               w-material)
          right-wall (sp/sphere (ma/mul
                                  (tr/translation 0. 0. 5.)
                                  (ma/mul
                                    (tr/rotation-y (/ Math/PI 4.))
                                    (ma/mul
                                      (tr/rotation-x (/ Math/PI 2.))
                                      (tr/scaling 10. 0.01 10.))))
                                w-material)
          middle (sp/sphere (tr/translation -0.5 1. 0.5)
                            (-> (mr/material)
                                (assoc :color (co/color 0.1 1. 0.5)
                                       :diffuse 0.7
                                       :specular 0.3)))
          right (sp/sphere (ma/mul (tr/translation 1.5 0.5 -0.5)
                                   (tr/scaling 0.5 0.5 0.5))
                           (-> (mr/material)
                               (assoc :color (co/color 0.5 1. 0.1)
                                      :diffuse 0.7
                                      :specular 0.3)))
          left (sp/sphere (ma/mul (tr/translation -1.5 0.33 -0.75)
                                  (tr/scaling 0.33 0.33 0.33))
                          (-> (mr/material)
                              (assoc :color (co/color 1. 0.8 0.1)
                                     :diffuse 0.7
                                     :specular 0.3)))
          light (li/point-light (tu/point -10. 10. -10.) (co/color 1. 1. 1.))
          world (wo/world [floor left-wall right-wall
                           middle left right]
                          [light])
          cam (cm/camera 200 100 (/ Math/PI 3)
                         (tr/view (tu/point 0. 1.5 -5.)
                                  (tu/point 0. 1. 0.)
                                  (tu/vector 0. 1. 0.)))
          cv (cm/render cam world)]
      ;; print the PPM file
      (spit "./samples/camera_world_example.ppm"
            (clojure.string/join "\n" (ca/ppm-rows cv)))))
  #+END_SRC

  [[file:../samples/camera_world_example.png]]
