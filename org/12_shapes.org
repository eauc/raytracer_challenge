#+TITLE: 12 - Shapes
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Creation

  #+NAME: shapes_create
  #+BEGIN_SRC clojure
  (defn shape
    ([local-bounds local-intersect local-normal transform material]
     (let [inverse-t (m/inverse transform)]
       {:local-bounds local-bounds
        :local-intersect local-intersect
        :local-normal local-normal
        :material material
        :transform transform
        :inverse-t inverse-t
        :trans-inverse-t (m/transpose inverse-t)}))
    ([local-bounds local-intersect local-normal transform]
     (shape local-bounds local-intersect local-normal transform mr/default-material))
    ([local-bounds local-intersect local-normal]
     (shape local-bounds local-intersect local-normal (m/id 4) mr/default-material)))
  #+END_SRC

* Bounds

  To calculate the world-boudaries of a shape:
  - calculate all 8 corners of the boundaries in local space.
  - transform each corner into world space.
  - take the min and max of all =x, y, z= coordinates.

  #+NAME: shapes_bounds_test
  #+BEGIN_SRC clojure
  (testing "Boundaries of a sphere with translation"
    (is (= {:min (t/point -0.5 0. 0.5)
            :max (t/point 1.5 2. 2.5)}
           (bounds (s/sphere (tr/translation 0.5 1. 1.5))))))

  (testing "Boundaries of a sphere with rotation"
    (let [bs (bounds (s/sphere (tr/rotation-x (/ Math/PI 4.))))]
      (is (t/eq? (t/point 1. (Math/sqrt 2.) (Math/sqrt 2.))
                 (:max bs)))
      (is (t/eq? (t/point -1. (- (Math/sqrt 2.)) (- (Math/sqrt 2.)))
                 (:min bs)))))

  (testing "Boundaries of a cube with scaling"
    (is (= {:min (t/point -0.5 -1.5 -2.)
            :max (t/point 0.5 1.5 2.)}
           (bounds (cu/cube (tr/scaling 0.5 1.5 2.))))))

  (testing "Boundaries of a triangle"
    (is (= {:min (t/point -1. -2. -3.)
            :max (t/point 3. 2. -1.)}
           (bounds (tg/triangle (t/point -1. -2. -3.)
                                (t/point 1. 2. -3.)
                                (t/point 3. -2. -1.))))))
  #+END_SRC

  #+NAME: shapes_bounds
  #+BEGIN_SRC clojure
  (defn bounds
    [{:keys [local-bounds transform] :as shape}]
    (let [{:keys [min max]} (local-bounds shape)
          coords (juxt t/x t/y t/z)
          [x-min y-min z-min] (coords min)
          [x-max y-max z-max] (coords max)
          corners (map #(m/mul transform %)
                       [(t/point x-min y-min z-min)
                        (t/point x-min y-min z-max)
                        (t/point x-min y-max z-min)
                        (t/point x-min y-max z-max)
                        (t/point x-max y-min z-min)
                        (t/point x-max y-min z-max)
                        (t/point x-max y-max z-min)
                        (t/point x-max y-max z-max)])
          xs (map t/x corners)
          ys (map t/y corners)
          zs (map t/z corners)]
      {:min (t/point (apply clojure.core/min xs)
                     (apply clojure.core/min ys)
                     (apply clojure.core/min zs))
       :max (t/point (apply clojure.core/max xs)
                     (apply clojure.core/max ys)
                     (apply clojure.core/max zs))}))
  #+END_SRC

* Intersections

  To calculate the world-intersect, we must first transform the ray in the object coordinates.

  #+NAME: shapes_ints
  #+BEGIN_SRC clojure
  (defn intersect [{:keys [inverse-t local-intersect] :as shape} ra]
    (let [local-ray (r/transform ra inverse-t)]
      (local-intersect shape local-ray)))
  #+END_SRC

* Normal

  =world->object= takes a point in world space and transform it to object space, taking into consideration any parent objects between the two spaces.

  #+NAME: shapes_w2o_test
  #+BEGIN_SRC clojure
  (testing "Converting a point from world to object space"
    (let [sphere (s/sphere (tr/translation 5. 0. 0.))
          g2 (gr/group (tr/scaling 2. 2. 2.) [sphere])
          g1 (gr/group (tr/rotation-y (/ Math/PI 2.)) [g2])]
      (is (t/eq? (t/point 0. 0. -1.)
                 (world->object (first (:children (first (:children g1))))
                                (t/point -2. 0. -10.))))))
  #+END_SRC

  #+NAME: shapes_w2o
  #+BEGIN_SRC clojure
  (defn world->object
    [{:keys [parent inverse-t] :as shape} point]
    (if (nil? shape)
      point
      (m/mul inverse-t (world->object parent point))))
  #+END_SRC

  =object->world= takes a normal vector in object space and transform it to world space, taking into consideration any parent objects between the two spaces.

  #+NAME: shapes_o2w_test
  #+BEGIN_SRC clojure
  (testing "Converting a normal from object to world space"
    (let [sphere (s/sphere (tr/translation 5. 0. 0.))
          g2 (gr/group (tr/scaling 1. 2. 3.) [sphere])
          g1 (gr/group (tr/rotation-y (/ Math/PI 2.)) [g2])
          sqrt3-on3 (/ (Math/sqrt 3.) 3.)]
      (is (t/eq? (t/vector 0.285714 0.428571 -0.857142)
                 (object->world (first (:children (first (:children g1))))
                                (t/vector sqrt3-on3 sqrt3-on3 sqrt3-on3))))))
  #+END_SRC

  #+NAME: shapes_o2w
  #+BEGIN_SRC clojure
  (defn object->world
    [{:keys [trans-inverse-t parent] :as shape} v]
    (let [[x y z] ((juxt t/x t/y t/z) (m/mul trans-inverse-t v))
          new-v (t/norm (t/vector x y z))]
      (if (nil? parent)
        new-v
        (object->world parent new-v))))
  #+END_SRC

  =shape/normal= must find the normal on a child object of a group, taking into account transformations on both the child object and the parent(s).

  #+NAME: shapes_normal_test
  #+BEGIN_SRC clojure
  (testing "Finding the normal on a child object"
    (let [sphere (s/sphere (tr/translation 5. 0. 0.))
          g2 (gr/group (tr/scaling 1. 2. 3.) [sphere])
          g1 (gr/group (tr/rotation-y (/ Math/PI 2.)) [g2])
          sqrt3-on3 (/ (Math/sqrt 3.) 3.)]
      (is (t/eq? (t/vector 0.285703 0.428543 -0.857160)
                 (normal (first (:children (first (:children g1))))
                         (t/point 1.7321 1.1547 -5.5774)
                         {})))))
  #+END_SRC

  To calculate the world-normal, we must :
  - first transform the intersection point into object-world.
  - then calculate the local-normal in object-world easily.
  - we must then transform this normal back, using the transpose inverse of the transformation matrix of the object.
  - this calculation results in a wrong =w= component, so we just trop it.
  - the resulting vector is also not normalized anymore, so we normalize the result.

  #+NAME: shapes_normal
  #+BEGIN_SRC clojure
  (defn normal [{:keys [local-normal] :as shape} world-point hit]
    (let [local-point (world->object shape world-point)
          local-normal (local-normal shape local-point hit)]
      (object->world shape local-normal)))
  #+END_SRC

* Files                                                           :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/shapes.clj
  (ns rt-clj.shapes
    (:require [rt-clj.matrices :as m]
              [rt-clj.materials :as mr]
              [rt-clj.rays :as r]
              [rt-clj.tuples :as t]))


  <<shapes_w2o>>


  <<shapes_o2w>>


  <<shapes_bounds>>


  <<shapes_ints>>


  <<shapes_normal>>


  <<shapes_create>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/shapes_test.clj
  (ns rt-clj.shapes-test
    (:require [clojure.test :refer :all]
              [rt-clj.shapes :refer :all]
              [rt-clj.cubes :as cu]
              [rt-clj.groups :as gr]
              [rt-clj.rays :as r]
              [rt-clj.spheres :as s]
              [rt-clj.transformations :as tr]
              [rt-clj.triangles :as tg]
              [rt-clj.tuples :as t]))

  (deftest shapes-test

    <<shapes_w2o_test>>

    <<shapes_o2w_test>>

    <<shapes_normal_test>>

    <<shapes_bounds_test>>)
  #+END_SRC
