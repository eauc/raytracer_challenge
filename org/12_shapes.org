#+TITLE: 12 - Shapes
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Creation

  #+NAME: shapes_create
  #+BEGIN_SRC clojure
  (defn shape
    ([local-intersect local-normal transform material]
     (let [inverse-t (m/inverse transform)]
       {:local-intersect local-intersect
        :local-normal local-normal
        :material material
        :transform transform
        :inverse-t inverse-t
        :trans-inverse-t (m/transpose inverse-t)}))
    ([local-intersect local-normal transform]
     (shape local-intersect local-normal transform mr/default-material))
    ([local-intersect local-normal]
     (shape local-intersect local-normal (m/id 4) mr/default-material)))
  #+END_SRC

* Intersections

  To calculate the world-intersect, we must first transform the ray in the object coordinates.

  #+NAME: shapes_ints
  #+BEGIN_SRC clojure
  (defn intersect [{:keys [inverse-t local-intersect] :as shape} ra]
    (let [local-ray (r/transform ra inverse-t)]
      (local-intersect shape local-ray)))
  #+END_SRC

* Normal

  =world->object= takes a point in world space and transform it to object space, taking into consideration any parent objects between the two spaces.

  #+NAME: shapes_w2o_test
  #+BEGIN_SRC clojure
  (testing "Converting a point from world to object space"
    (let [sphere (s/sphere (tr/translation 5. 0. 0.))
          g2 (gr/group (tr/scaling 2. 2. 2.) [sphere])
          g1 (gr/group (tr/rotation-y (/ Math/PI 2.)) [g2])]
      (is (t/eq? (t/point 0. 0. -1.)
                 (world->object (first (:children (first (:children g1))))
                                (t/point -2. 0. -10.))))))
  #+END_SRC

  #+NAME: shapes_w2o
  #+BEGIN_SRC clojure
  (defn world->object
    [{:keys [parent inverse-t] :as shape} point]
    (if (nil? shape)
      point
      (m/mul inverse-t (world->object parent point))))
  #+END_SRC

  =object->world= takes a normal vector in object space and transform it to world space, taking into consideration any parent objects between the two spaces.

  #+NAME: shapes_o2w_test
  #+BEGIN_SRC clojure
  (testing "Converting a normal from object to world space"
    (let [sphere (s/sphere (tr/translation 5. 0. 0.))
          g2 (gr/group (tr/scaling 1. 2. 3.) [sphere])
          g1 (gr/group (tr/rotation-y (/ Math/PI 2.)) [g2])
          sqrt3-on3 (/ (Math/sqrt 3.) 3.)]
      (is (t/eq? (t/vector 0.285714 0.428571 -0.857142)
                 (object->world (first (:children (first (:children g1))))
                                (t/vector sqrt3-on3 sqrt3-on3 sqrt3-on3))))))
  #+END_SRC

  #+NAME: shapes_o2w
  #+BEGIN_SRC clojure
  (defn object->world
    [{:keys [trans-inverse-t parent] :as shape} v]
    (let [[x y z] ((juxt t/x t/y t/z) (m/mul trans-inverse-t v))
          new-v (t/norm (t/vector x y z))]
      (if (nil? parent)
        new-v
        (object->world parent new-v))))
  #+END_SRC

  =shape/normal= must find the normal on a child object of a group, taking into account transformations on both the child object and the parent(s).

  #+NAME: shapes_normal_test
  #+BEGIN_SRC clojure
  (testing "Finding the normal on a child object"
    (let [sphere (s/sphere (tr/translation 5. 0. 0.))
          g2 (gr/group (tr/scaling 1. 2. 3.) [sphere])
          g1 (gr/group (tr/rotation-y (/ Math/PI 2.)) [g2])
          sqrt3-on3 (/ (Math/sqrt 3.) 3.)]
      (is (t/eq? (t/vector 0.285703 0.428543 -0.857160)
                 (normal (first (:children (first (:children g1))))
                         (t/point 1.7321 1.1547 -5.5774)
                         {})))))
  #+END_SRC

  To calculate the world-normal, we must :
  - first transform the intersection point into object-world.
  - then calculate the local-normal in object-world easily.
  - we must then transform this normal back, using the transpose inverse of the transformation matrix of the object.
  - this calculation results in a wrong =w= component, so we just trop it.
  - the resulting vector is also not normalized anymore, so we normalize the result.

  #+NAME: shapes_normal
  #+BEGIN_SRC clojure
  (defn normal [{:keys [local-normal] :as shape} world-point hit]
    (let [local-point (world->object shape world-point)
          local-normal (local-normal shape local-point hit)]
      (object->world shape local-normal)))
  #+END_SRC

* Files                                                           :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/shapes.clj
  (ns rt-clj.shapes
    (:require [rt-clj.matrices :as m]
              [rt-clj.materials :as mr]
              [rt-clj.rays :as r]
              [rt-clj.tuples :as t]))


  <<shapes_w2o>>


  <<shapes_o2w>>


  <<shapes_ints>>


  <<shapes_normal>>


  <<shapes_create>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/shapes_test.clj
  (ns rt-clj.shapes-test
    (:require [clojure.test :refer :all]
              [rt-clj.shapes :refer :all]
              [rt-clj.groups :as gr]
              [rt-clj.rays :as r]
              [rt-clj.spheres :as s]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]))

  (deftest shapes-test

    <<shapes_w2o_test>>

    <<shapes_o2w_test>>

    <<shapes_normal_test>>)
  #+END_SRC
