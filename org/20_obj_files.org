#+TITLE: 20 - OBJ Files
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

The Wavefront OBJ file format is a common format for storing and sharing 3D graphics data. The OBJ format is plain text, which means you can view, edit, and even create these files in any text editor, though it’s much easier to model something in a 3D modeling tool and then export it to OBJ.

[[file:../samples/obj_teapot_low_example.png]]

[[file:../samples/obj_teapot_example.png]]

The OBJ format consists of statements, each of which occupies a single line. Each statement is prefaced with a command, followed by a space-delimited list of arguments. For example, the following OBJ file defines three vertices ( v ), and a triangle ( f , for “face”) that references those vertices.

#+BEGIN_SRC text
v 1.5 2 1.3
v 1.4 -1.2 0.12
v -0.1 0 -1.3
f 1 2 3
#+END_SRC

* Parsing

  The parser should silently ignore any unrecognized statements.

  #+NAME: obj_ignore_test
  #+BEGIN_SRC clojure
  (testing "Ignoring unrecognized lines"
    (is (= {:group (assoc (gr/group) :material mr/default-material)
            :normals []
            :vertices []}
           (parse-lines ["There was a young lady named Bright"
                         "who traveled much faster than light."
                         "She set out one day"
                         "in a relative way,"
                         "and came back the previous night."]))))
  #+END_SRC

  The parser should process vertex data from the given input.

  Each vertex statement starts with a =v= followed by a space character, and then three integer or floating point numbers delimited by spaces.

  #+NAME: obj_vertices_test
  #+BEGIN_SRC clojure
  (testing "Vertex records"
    (is (= [(t/point -1. 1. 0.)
            (t/point -1. 0.5 0.)
            (t/point 1. 0. 0.)
            (t/point 1. 1. 0.)]
           (:vertices (parse-lines ["v -1 1 0"
                                    "v -1.0000 0.5000 0.0000"
                                    "v 1 0 0"
                                    "v 1 1 0"])))))
  #+END_SRC

  Vertex normal data should be correctly imported from an OBJ file.

  #+NAME: obj_normals_test
  #+BEGIN_SRC clojure
  (testing "Vertex normal records"
    (let [normals (:normals (parse-lines ["vn 0 0 1"
                                          "vn 0.707 0 -0.707"
                                          "vn 1 2 3"]))]
      (is (= (t/vector 0. 0. 1.)
             (nth normals 0)))
      (is (t/eq? (t/vector 0.707 0. -0.707)
                 (nth normals 1)))
      (is (= (t/vector 1. 2. 3.)
             (nth normals 2)))))
  #+END_SRC

  The parser should process triangle data from the given input.

  The triangles are introduced with the f command (for "face"), followed by three integers referring to the corresponding vertices. Note that these indices are 1-based, and not 0-based!

  #+NAME: obj_triangles_test
  #+BEGIN_SRC clojure
  (testing "Parsing triangle faces"
    (let [result (parse-lines ["v -1 1 0"
                               "v -1 0 0"
                               "v 1 0 0"
                               "v 1 1 0"
                               "f 1 2 3"
                               "f 1 3 4"])]
      (is (= (gr/with-children
               (assoc (gr/group) :material mr/default-material)
               [(tg/triangle (nth (:vertices result) 0)
                             (nth (:vertices result) 1)
                             (nth (:vertices result) 2))
                (tg/triangle (nth (:vertices result) 0)
                             (nth (:vertices result) 2)
                             (nth (:vertices result) 3))])
             (:group result)))))
  #+END_SRC

  The parser should process and triangulate polygonal data from the given input.

  Our ray tracer only knows how to render triangles, though, so it needs to be able to break that polygon apart into triangles.

  #+NAME: obj_polygons_test
  #+BEGIN_SRC clojure
  (testing "Triangulating polygons"
    (let [result (parse-lines ["v -1 1 0"
                               "v -1 0 0"
                               "v 1 0 0"
                               "v 1 1 0"
                               "v 0 2 0"
                               "f 1 2 3 4 5"])]
      (is (= (gr/with-children
               (assoc (gr/group) :material mr/default-material)
               [(tg/triangle (nth (:vertices result) 0)
                             (nth (:vertices result) 1)
                             (nth (:vertices result) 2))
                (tg/triangle (nth (:vertices result) 0)
                             (nth (:vertices result) 2)
                             (nth (:vertices result) 3))
                (tg/triangle (nth (:vertices result) 0)
                             (nth (:vertices result) 3)
                             (nth (:vertices result) 4))])
             (:group result)))))
  #+END_SRC

  Vertex normal data should be correctly associated with face data from an OBJ file.

  #+NAME: obj_faces_normals_test
  #+BEGIN_SRC clojure
  (testing "Faces with normals"
    (let [result (parse-lines ["v 0 1 0"
                               "v -1 0 0"
                               "v 1 0 0"
                               "vn -1 0 0"
                               "vn 1 0 0"
                               "vn 0 1 0"
                               "f 1//3 2//1 3//2"
                               "f 1/0/3 2/102/1 3/14/2"])]
      (= (gr/with-children
           (gr/group)
           [(tg/smooth-triangle (nth (:vertices result) 0)
                                (nth (:vertices result) 1)
                                (nth (:vertices result) 2)
                                (nth (:normals result) 2)
                                (nth (:normals result) 0)
                                (nth (:normals result) 1))
            (tg/smooth-triangle (nth (:vertices result) 0)
                                (nth (:vertices result) 1)
                                (nth (:vertices result) 2)
                                (nth (:normals result) 2)
                                (nth (:normals result) 0)
                                (nth (:normals result) 1))])
         result)))
  #+END_SRC


  The parser should recognize a group statement and add subsequent triangles to the named group.

  #+NAME: obj_groups_test
  #+BEGIN_SRC clojure
  (testing "Triangles in groups"
    (let [result (parse-lines ["v -1 1 0"
                               "v -1 0 0"
                               "v 1 0 0"
                               "v 1 1 0"
                               "g FirstGroup"
                               "f 1 2 3"
                               "g SecondGroup"
                               "f 1 3 4"])]
      (is (= (gr/with-children
               (assoc (gr/group) :material mr/default-material)
               [(gr/with-children
                  (assoc (gr/group) :name "FirstGroup")
                  [(tg/triangle (nth (:vertices result) 0)
                                (nth (:vertices result) 1)
                                (nth (:vertices result) 2))])
                (gr/with-children
                  (assoc (gr/group) :name "SecondGroup")
                  [(tg/triangle (nth (:vertices result) 0)
                                (nth (:vertices result) 2)
                                (nth (:vertices result) 3))])])
             (:group result)))))
  #+END_SRC

  #+NAME: obj_parse_lines
  #+BEGIN_SRC clojure
  (defn polygon->triangles
    [normals vertices raw-indices]
    (let [indices (map (fn [raw]
                         (map (fn [i-string]
                                (if (empty? i-string)
                                  nil
                                  (Integer/parseInt i-string)))
                              (clojure.string/split raw #"/")))
                       raw-indices)
          [v1 & vs] (map #(nth vertices (dec (first %))) indices)
          [n1 & ns] (map (fn [[_ _ vn]]
                           (if (nil? vn)
                             vn
                             (nth normals (dec vn)))) indices)]
      (loop [[v2 & v-rest] vs
             [n2 & n-rest] ns
             triangles []]
        (if-not (and v2 (first v-rest))
          triangles
          (recur v-rest n-rest
                 (conj triangles
                       (if (nil? n1)
                         (tg/triangle v1 v2 (first v-rest))
                         (tg/smooth-triangle v1 v2 (first v-rest)
                                             n1 n2 (first n-rest)))))))))


  (defn parse-lines
    ([lines material]
     (let [[current-group
            groups
            normals
            triangles
            vertices] (loop [[l & rest] lines
                             current-group "default"
                             groups {}
                             normals []
                             triangles []
                             vertices []]
            (if (nil? l)
              [current-group groups normals triangles vertices]
              (cond
                (re-find #"^v " l)
                (let [[_ x y z] (clojure.string/split l #"\s+")]
                  (recur rest
                         current-group
                         groups
                         normals
                         triangles
                         (conj vertices (t/point (Float/parseFloat x)
                                                 (Float/parseFloat y)
                                                 (Float/parseFloat z)))))
                (re-find #"^vn " l)
                (let [[_ x y z] (clojure.string/split l #"\s+")]
                  (recur rest
                         current-group
                         groups
                         (conj normals (t/vector (Float/parseFloat x)
                                                 (Float/parseFloat y)
                                                 (Float/parseFloat z)))
                         triangles
                         vertices))
                (re-find #"^f " l)
                (let [[_ & ps] (clojure.string/split l #"\s+")]
                  (recur rest
                         current-group
                         groups
                         normals
                         (into
                           []
                           (concat triangles
                                   (polygon->triangles normals vertices ps)))
                         vertices))
                (re-find #"^g " l)
                (let [[_ new-group] (clojure.string/split l #"\s+")]
                  (recur rest
                         new-group
                         (assoc groups current-group triangles)
                         normals
                         []
                         vertices))
                :else
                (recur rest current-group groups normals triangles vertices))))
           groups (assoc groups current-group triangles)]
       {:group (gr/with-children
                 (assoc (gr/group) :material material)
                 (concat
                   (get groups "default")
                   (map (fn [[name children]]
                          (gr/with-children
                            (assoc (gr/group) :name name)
                            children))
                        (dissoc groups "default"))))
        :normals normals
        :vertices vertices}))
    ([lines]
     (parse-lines lines mr/default-material)))
  #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/obj_files.clj
  (ns rt-clj.obj-files
    (:require [rt-clj.groups :as gr]
              [rt-clj.materials :as mr]
              [rt-clj.triangles :as tg]
              [rt-clj.tuples :as t]))


  <<obj_parse_lines>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/obj_files_test.clj
  (ns rt-clj.obj-files-test
    (:require [clojure.test :refer :all]
              [rt-clj.obj-files :refer :all]
              [rt-clj.groups :as gr]
              [rt-clj.materials :as mr]
              [rt-clj.triangles :as tg]
              [rt-clj.tuples :as t]))

  (deftest obj-files-test

    <<obj_ignore_test>>

    <<obj_vertices_test>>

    <<obj_normals_test>>

    <<obj_triangles_test>>

    <<obj_polygons_test>>

    <<obj_faces_normals_test>>

    <<obj_groups_test>>)
  #+END_SRC
