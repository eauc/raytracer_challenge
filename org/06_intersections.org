#+TITLE: 06 - Intersections
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

* Creation

  Intersections store the object hit and the distance from origin on the ray.

  #+NAME: ints_create_test
  #+BEGIN_SRC clojure
  (testing "An intersection encapsulates 't' and 'object'"
    (let [s {:object :test}
          i (intersection 3.5 s)]
      (is (= 3.5
             (:t i)))
      (is (= s
             (:object i)))))

  (testing "Aggregating intersections"
    (let [s {:object :test}
          i1 (intersection 1. s)
          i2 (intersection 2. s)
          xs (intersections i1 i2)]
      (is (= 2
             (count xs)))
      (is (= 1.
             (:t (first xs))))
      (is (= 2.
             (:t (second xs))))))
  #+END_SRC

  #+NAME: ints_create
  #+BEGIN_SRC clojure
  (defn intersection [t object]
    {:t t
     :object object})

  (def intersections vector)
  #+END_SRC

  To help with the ray tracer computations, the =prepare-hit= function pre-computes some values and add them to an intersection:
  - the point in world space where the hit occured.
  - the eye vector (pointing towards the camera).
  - the normal of the object at the intersection point.
  - whether the intersection occurs on the inside of the object, in which case the normal is inverted.

  To avoid acne syndrome, the computation should slightly displace the hit point (by epsilon) toward the outside of the object.

  #+NAME: ints_prep_test
  #+BEGIN_SRC clojure
  (testing "Precomputing the state of an intersection"
    (let [ray (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          shape (s/sphere)
          hit (intersection 4 shape)
          p (prepare-hit hit ray [hit])]
      (is (t/eq? (t/point 0. 0. -1.00001)
                 (:point p)))
      (is (t/eq? (t/vector 0. 0. -1.)
                 (:eyev p)))
      (is (t/eq? (t/vector 0. 0. -1.)
                 (:normalv p)))))

  (testing "An intersection occurs on the outside"
    (let [ray (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          shape (s/sphere)
          hit (intersection 1. shape)
          p (prepare-hit hit ray [hit])]
      (is (= false
             (:inside? p)))))

  (testing "An intersection occurs on the inside"
    (let [ray (r/ray (t/point 0. 0. 0.) (t/vector 0. 0. 1.))
          shape (s/sphere)
          hit (intersection 1. shape)
          p (prepare-hit hit ray [hit])]
      (is (t/eq? (t/point 0. 0. 0.99999)
                 (:point p)))
      (is (t/eq? (t/vector 0. 0. -1.)
                 (:eyev p)))
      (is (= true
             (:inside? p)))
      (is (t/eq? (t/vector 0. 0. -1.)
                 (:normalv p)))))

  (testing "The hit should offset the point"
    (let [ray (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          shape (s/sphere (tr/translation 0. 0. 1.))
          h (intersection 5. shape)]
      (is (> (- (/ t/epsilon 2))
             (t/z (:point (prepare-hit h ray [h])))))))

  (testing "Precomputing the reflection vector"
    (let [shape (p/plane)
          ray (r/ray (t/point 0. 1. -1.) (t/vector 0. (- (/ (Math/sqrt 2.) 2)) (/ (Math/sqrt 2.) 2)))
          int (intersection (Math/sqrt 2.) shape)]
      (is (= (t/vector 0. (/ (Math/sqrt 2.) 2) (/ (Math/sqrt 2.) 2))
             (:reflectv (prepare-hit int ray [int]))))))
  #+END_SRC

  #+NAME: ints_prep
  #+BEGIN_SRC clojure
  (defn prepare-hit [hit ray ints]
    (let [point (r/pos ray (:t hit))
          normalv' (sh/normal (:object hit) point hit)
          eyev (t/sub t/zerov (:direction ray))
          inside? (< (t/dot normalv' eyev) 0)
          normalv (if inside? (t/sub t/zerov normalv') normalv')
          n (refractive-indices hit ints)]
      (assoc hit
             :point (t/add point (t/mul normalv t/epsilon))
             :under-point (t/sub point (t/mul normalv t/epsilon))
             :eyev eyev
             :n n
             :normalv normalv
             :inside? inside?
             :reflectv (t/reflect (:direction ray) normalv))))
  #+END_SRC

* Hit

  We can find a hit in a list of intersections. It's always the lowest non-negative intersection.

  #+NAME: ints_hit_test
  #+BEGIN_SRC clojure
  (testing "The hit, when all intersections have positive t"
    (let [s {:object :test}
          i1 (intersection 1. s)
          i2 (intersection 2. s)
          xs (intersections i2 i1)]
      (is (= i1
             (hit xs)))))

  (testing "The hit, when some intersections have negative t"
    (let [s {:object :test}
          i1 (intersection -1. s)
          i2 (intersection 2. s)
          xs (intersections i2 i1)]
      (is (= i2
             (hit xs)))))

  (testing "The hit, when all intersections have negative t"
    (let [s {:object :test}
          i1 (intersection -1. s)
          i2 (intersection -2. s)
          xs (intersections i2 i1)]
      (is (= nil
             (hit xs)))))

  (testing "The hit is always the lowest non-negative intersection"
    (let [s {:object :test}
          i1 (intersection 5. s)
          i2 (intersection 7. s)
          i3 (intersection -3. s)
          i4 (intersection 2. s)
          xs (intersections i2 i1 i3 i4)]
      (is (= i4
             (hit xs)))))
  #+END_SRC

  #+NAME: ints_hit
  #+BEGIN_SRC clojure
  (defn hit [is]
    (first (sort-by :t (filter #(< 0 (:t %)) is))))
  #+END_SRC

* Refraction

  We also need to determine the refractive indices on each side of the intersection.

  #+NAME: ints_refraction_test
  #+BEGIN_SRC clojure
  (testing "Finding n1 and n2 at various intersections"
    (let [A (s/sphere
              (tr/scaling 2. 2. 2.)
              (assoc m/glass :refractive-index 1.5))
          B (s/sphere
              (tr/translation 0. 0. -0.25)
              (assoc m/glass :refractive-index 2.))
          C (s/sphere
              (tr/translation 0. 0. 0.25)
              (assoc m/glass :refractive-index 2.5))
          ray (r/ray (t/point 0. 0. -4.) (t/vector 0. 0. 1.))
          xs [(intersection 2. A)
              (intersection 2.75 B)
              (intersection 3.25 C)
              (intersection 4.75 B)
              (intersection 5.25 C)
              (intersection 6. A)]]
      (are [k n] (= n
                    (:n (prepare-hit (nth xs k) ray xs)))
        0 [1.0 1.5]
        1 [1.5 2.0]
        2 [2.0 2.5]
        3 [2.5 2.5]
        4 [2.5 1.5]
        5 [1.5 1.0])))
  #+END_SRC

  #+NAME: ints_refraction
  #+BEGIN_SRC clojure
  (defn refractive-indices
    [hit ints]
    (loop [[current & rest] ints
           containers []]
      (let [is-hit? (= current hit)
            object (:object current)
            next-containers (if (first (filter #(= % object) containers))
                              (filterv #(not= % object) containers)
                              (conj containers object))]
        (if is-hit?
          [(if (empty? containers)
             1.
             (get-in (last containers) [:material :refractive-index] 1.))
           (if (empty? next-containers)
             1.
             (get-in (last next-containers) [:material :refractive-index] 1.))]
          (if (empty? rest)
            [1. 1.]
            (recur rest next-containers))))))
  #+END_SRC

  We also need to calculate the origin of the refracted ray, just under the surface at intersection.

  #+NAME: ints_under_point_test
  #+BEGIN_SRC clojure
  (testing "The under point is offset below the surface"
    (let [ray (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))
          shape (s/sphere
                  (tr/translation 0. 0. 1.)
                  m/glass)
          inter (intersection 5. shape)
          xs [inter]
          hit (prepare-hit inter ray xs)]
      (< (/ t/epsilon 2.)
         (t/z (:under-point hit)))
      (< (t/z (:point hit))
         (t/z (:under-point hit)))))
  #+END_SRC

* Reflectance

  [[file:../samples/fresnel_example.png]]

  The =schlick= function returns a number between 0 and 1, inclusive.
  This number is called the reflectance and represents what fraction of the light is reflected, given the surface information at the hit.
  - reflectance is 1. when facing total internal reflection.
  - reflectance is close to 0. when incident ray is perpendicular to surface.
  - reflectance is significant when n 2 > n 1 and the ray strikes the surface at a small angle.

  #+NAME: ints_schlick_test
  #+BEGIN_SRC clojure
  (testing "The Schlick approximation under total internal reflection"
    (let [shape (s/sphere (ma/id 4) m/glass)
          sqrt2_on2 (/ (Math/sqrt 2.) 2.)
          ray (r/ray (t/point 0. 0. sqrt2_on2) (t/vector 0. 1. 0.))
          xs [(intersection (- sqrt2_on2) shape)
              (intersection sqrt2_on2 shape)]
          hit (prepare-hit (nth xs 1) ray xs)]
      (is (= 1. (schlick hit)))))

  (testing "The Schlick approximation with a perpendicular viewing angle"
    (let [shape (s/sphere (ma/id 4) m/glass)
          ray (r/ray (t/point 0. 0. 0.) (t/vector 0. 1. 0.))
          xs [(intersection -1. shape)
              (intersection 1. shape)]
          hit (prepare-hit (nth xs 1) ray xs)]
      (is (t/close? 0.04
                    (schlick hit)))))

  (testing "The Schlick approximation with small angle and n2 > n1"
    (let [shape (s/sphere (ma/id 4) m/glass)
          ray (r/ray (t/point 0. 0.99 -2.) (t/vector 0. 0. 1.))
          xs [(intersection 1.8589 shape)]
          hit (prepare-hit (first xs) ray xs)]
      (is (t/close? 0.488730
                    (schlick hit)))))
  #+END_SRC

  #+NAME: ints_schlick
  #+BEGIN_SRC clojure
  (defn schlick
    [{:keys [eyev normalv n] :as hit}]
    (let [[n1 n2] n
          cos-i (t/dot eyev normalv)
          n-ratio (/ n1 n2)
          sin-t-square (* n-ratio n-ratio (- 1. (* cos-i cos-i)))]
      (if (and (> n1 n2)
               (> sin-t-square 1.))
        1.
        (let [cos-t (Math/sqrt (- 1. sin-t-square))
              cos (if (> n1 n2) cos-t cos-i)
              r0 (Math/pow (/ (- n1 n2) (+ n1 n2)) 2.)]
          (+ r0 (* (- 1. r0) (Math/pow (- 1. cos) 5)))))))
  #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/intersections.clj
  (ns rt-clj.intersections
    (:require [rt-clj.rays :as r]
              [rt-clj.shapes :as sh]
              [rt-clj.tuples :as t]))


  <<ints_create>>


  <<ints_refraction>>


  <<ints_prep>>


  <<ints_hit>>


  <<ints_schlick>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/intersections_test.clj
  (ns rt-clj.intersections-test
    (:require [clojure.test :refer :all]
              [rt-clj.intersections :refer :all]
              [rt-clj.matrices :as ma]
              [rt-clj.materials :as m]
              [rt-clj.planes :as p]
              [rt-clj.rays :as r]
              [rt-clj.spheres :as s]
              [rt-clj.tuples :as t]
              [rt-clj.transformations :as tr]))

  (deftest intersections-test
    <<ints_create_test>>

    <<ints_prep_test>>

    <<ints_refraction_test>>

    <<ints_under_point_test>>

    <<ints_hit_test>>

    <<ints_schlick_test>>)
  #+END_SRC
