#+TITLE: 21 - CSG Shapes
#+SETUPFILE: ./publish.setup
#+PROPERTY: header-args :exports code :tangle no

[[./index.org][Documentation index]]

[[file:../samples/csg_spheres_example.png]]

[[file:../samples/csg_cube_example.png]]

[[file:../samples/csg_lens_example.png]]

* Creation

  A CSG shape is composed of an operation and two operand shapes.

  #+NAME: csg_create_test
  #+BEGIN_SRC clojure
  (testing "CSG is created with an operation and two shapes"
    (let [s1 (sp/sphere)
          s2 (cu/cube)
          shape (csg :union s1 s2)]
      (is (= :union
             (:operation shape)))
      (is (= s1
             (dissoc (:left shape) :parent)))
      (is (= s2
             (dissoc (:right shape) :parent)))
      (is (= :union
             (get-in shape [:right :parent :operation])))
      (is (= :union
             (get-in shape [:left :parent :operation])))))
  #+END_SRC

  #+NAME: csg_create
  #+BEGIN_SRC clojure
  (defn csg
    ([transform operation left right]
     (let [shape (-> (sh/shape local-intersect identity transform)
                     (assoc
                       :operation operation
                       :left left
                       :right right))]
       (assoc shape
              :left (assoc left :parent shape)
              :right (assoc right :parent shape))))
    ([operation left right]
     (csg (m/id 4) operation left right)))
  #+END_SRC

* Intersections

  A CSG union preserves all intersections on the exterior of both shapes.

  A CSG intersect preserves all intersections where both shapes overlap.

  A CSG difference preserves all intersections not exclusively inside the object on the right.

  #+NAME: csg_int_allowed_test
  #+BEGIN_SRC clojure
  (testing "Evaluating the rule for a CSG operation"
    (are [op lhit inl inr result]
        (= result
           (intersection-allowed op lhit inl inr))
        :union true true  true  false
        :union true true  false true
        :union true false true  false
        :union true false false true
        :union false true true  false
        :union false true false false
        :union false false true   true
        :union false false false  true
        :intersection true true true true
        :intersection true true false false
        :intersection true false true true
        :intersection true false false false
        :intersection false true true true
        :intersection false true false true
        :intersection false false true false
        :intersection false false false false
        :difference true true true false
        :difference true true false true
        :difference true false true false
        :difference true false false true
        :difference false true true true
        :difference false true false true
        :difference false false true false
        :difference false false false false))
  #+END_SRC

  Given a set of intersections, produce a subset of only those intersections that conform to the operation of the current CSG object.

  #+NAME: csg_filter_ints_test
  #+BEGIN_SRC clojure
  (testing "Filtering a list of intersections"
    (let [s1 (sp/sphere)
          s2 (cu/cube)]
      (let [shape (csg :union s1 s2)
            ints [(i/intersection 1. (:left shape))
                  (i/intersection 2. (:right shape))
                  (i/intersection 3. (:left shape))
                  (i/intersection 4. (:right shape))]]
        (is (= [(nth ints 0)
                (nth ints 3)]
               (filter-intersections shape ints))))))
  #+END_SRC

  A ray should intersect a CSG object if it intersects any of its children.

  #+NAME: csg_int_test
  #+BEGIN_SRC clojure
  (testing "A ray misses a CSG object"
    (let [shape (csg :union (sp/sphere) (cu/cube))
          ray (r/ray (t/point 0. 2. -5.) (t/vector 0. 0. 1.))]
      (is (= []
             (local-intersect shape ray)))))

  (testing "A ray hits a CSG object"
    (let [s1 (sp/sphere)
          s2 (sp/sphere (tr/translation 0. 0. 0.5))
          shape (csg :union s1 s2)
          ray (r/ray (t/point 0. 0. -5.) (t/vector 0. 0. 1.))]
      (is (= [(i/intersection 4. (:left shape))
              (i/intersection 6.5 (:right shape))]
             (local-intersect shape ray)))))
  #+END_SRC

  #+NAME: csg_int
  #+BEGIN_SRC clojure
  (defmulti intersection-allowed (fn [op _ _ _] op))


  (defmethod intersection-allowed :default
    [_ _ _ _]
    false)


  (defmethod intersection-allowed :union
    [_ lhit inl inr]
    (or (and lhit (not inr))
        (and (not lhit) (not inl))))


  (defmethod intersection-allowed :intersection
    [_ lhit inl inr]
    (or (and lhit inr)
        (and (not lhit) inl)))


  (defmethod intersection-allowed :difference
    [_ lhit inl inr]
    (or (and lhit (not inr))
        (and (not lhit) inl)))


  (defn includes?
    [{:keys [left right children] :as parent} child]
    (cond
      (not (nil? children))
      (some #(includes? % child) children)
      (not (nil? left))
      (or (includes? left child)
          (includes? right child))
      :else
      (= parent child)))


  (defn filter-intersections
    [{:keys [operation left right] :as shape} ints]
    (loop [[{:keys [object] :as int} & rest] ints
           inl false
           inr false
           result []]
      (if (nil? int)
        result
        (let [lhit (includes? left object)
              allowed? (intersection-allowed operation lhit inl inr)
              result' (if allowed? (conj result int) result)
              inl' (if lhit (not inl) inl)
              inr' (if lhit inr (not inr))]
          (recur rest inl' inr' result')))))


  (defn local-intersect
    [{:keys [left right] :as shape} ray]
    (filter-intersections
      shape
      (sort-by
        :t
        (concat (sh/intersect left ray)
                (sh/intersect right ray)))))
  #+END_SRC

* Files                                                            :noexport:
  :PROPERTIES:
  :header-args: :exports none :noweb yes
  :END:

  #+BEGIN_SRC clojure :tangle ../src/rt_clj/csg_shapes.clj
  (ns rt-clj.csg-shapes
    (:require [rt-clj.matrices :as m]
              [rt-clj.shapes :as sh]))


  <<csg_int>>


  <<csg_create>>
  #+END_SRC

  #+BEGIN_SRC clojure :tangle ../test/rt_clj/csg_shapes_test.clj
  (ns rt-clj.csg-shapes-test
    (:require [clojure.test :refer :all]
              [rt-clj.csg-shapes :refer :all]
              [rt-clj.cubes :as cu]
              [rt-clj.intersections :as i]
              [rt-clj.rays :as r]
              [rt-clj.spheres :as sp]
              [rt-clj.transformations :as tr]
              [rt-clj.tuples :as t]))

  (deftest csg-shapes-test

    <<csg_create_test>>

    <<csg_int_allowed_test>>

    <<csg_filter_ints_test>>

    <<csg_int_test>>)
  #+END_SRC
